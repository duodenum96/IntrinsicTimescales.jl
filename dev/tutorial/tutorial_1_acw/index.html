<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Navigating the Forest of INT Metrics · IntrinsicTimescales.jl</title><meta name="title" content="Navigating the Forest of INT Metrics · IntrinsicTimescales.jl"/><meta property="og:title" content="Navigating the Forest of INT Metrics · IntrinsicTimescales.jl"/><meta property="twitter:title" content="Navigating the Forest of INT Metrics · IntrinsicTimescales.jl"/><meta name="description" content="Documentation for IntrinsicTimescales.jl."/><meta property="og:description" content="Documentation for IntrinsicTimescales.jl."/><meta property="twitter:description" content="Documentation for IntrinsicTimescales.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../home/">IntrinsicTimescales.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../home/">Getting Started</a></li><li><span class="tocitem">Practice</span><ul><li><a class="tocitem" href="../../practice/practice_intro/">Practice</a></li><li><a class="tocitem" href="../../practice/practice_1_acf/">Building the Autocorrelation Function</a></li><li><a class="tocitem" href="../../practice/practice_2_acw/">Autocorrelation Windows</a></li><li><a class="tocitem" href="../../practice/practice_3_ou/">Ornstein-Uhlenbeck Process as a Generative Model for ACF</a></li><li><a class="tocitem" href="../../practice/practice_4_psd/">Dealing with Oscillatory Artifacts using Fourier Transformation</a></li><li><a class="tocitem" href="../../practice/practice_5_bayesian/">Bayesian Estimation of Intrinsic Timescales</a></li></ul></li><li><a class="tocitem" href="../../theory/theory/">Theory</a></li><li class="is-active"><a class="tocitem" href>Navigating the Forest of INT Metrics</a><ul class="internal"><li><a class="tocitem" href="#Getting-ACW-0-Out-of-the-Way:"><span>Getting ACW-0 Out of the Way:</span></a></li><li><a class="tocitem" href="#ACF-vs-PSD-based-methods"><span>ACF vs PSD based methods</span></a></li><li><a class="tocitem" href="#:tau-vs-:acw*"><span><code>:tau</code> vs <code>:acw*</code></span></a></li><li><a class="tocitem" href="#When-to-use-:auc?"><span>When to use <code>:auc</code>?</span></a></li><li><a class="tocitem" href="#Should-I-average_over_trials?"><span>Should I <code>average_over_trials</code>?</span></a></li><li><a class="tocitem" href="#Should-I-skip_zero_lag?"><span>Should I <code>skip_zero_lag</code>?</span></a></li><li><a class="tocitem" href="#Should-I-allow_variable_exponent?"><span>Should I <code>allow_variable_exponent</code>?</span></a></li><li><a class="tocitem" href="#Should-I-set-constrainedtrue?"><span>Should I set <code>constrained=true</code>?</span></a></li><li><a class="tocitem" href="#Should-I-use-paralleltrue?"><span>Should I use <code>parallel=true</code>?</span></a></li><li><a class="tocitem" href="#When-to-use-Bayesian-methods?"><span>When to use Bayesian methods?</span></a></li><li><a class="tocitem" href="#Can-I-calculate-INTs-in-task-trials-(ERP/ERF/ASSR-and-so-on)?"><span>Can I calculate INTs in task trials (ERP/ERF/ASSR and so on)?</span></a></li><li><a class="tocitem" href="#TL;DR"><span>TL;DR</span></a></li></ul></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../../acw/">Model-Free Timescale Estimation</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Simulation Based Timescale Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simbasedinference/">Overview</a></li><li><a class="tocitem" href="../../one_timescale/">One Timescale Model</a></li><li><a class="tocitem" href="../../one_timescale_with_missing/">One Timescale Model with Missing Data</a></li><li><a class="tocitem" href="../../one_timescale_and_osc/">One Timescale Model with Oscillations</a></li><li><a class="tocitem" href="../../one_timescale_and_osc_with_missing/">One Timescale Model with Oscillations and Missing Data</a></li><li><a class="tocitem" href="../../fit_parameters/">Model Fitting and Parameters</a></li><li><a class="tocitem" href="../../fit_result/">Results</a></li></ul></li></ul></li><li><a class="tocitem" href="../../">API</a></li><li><a class="tocitem" href="../../citations/">Citations</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../developer/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Navigating the Forest of INT Metrics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Navigating the Forest of INT Metrics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/master/docs/src/tutorial/tutorial_1_acw.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Navigating-the-Forest-of-INT-Metrics"><a class="docs-heading-anchor" href="#Navigating-the-Forest-of-INT-Metrics">Navigating the Forest of INT Metrics</a><a id="Navigating-the-Forest-of-INT-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Navigating-the-Forest-of-INT-Metrics" title="Permalink"></a></h1><p>The main user-facing function in IntrinsicTimescales.jl is <a href="../../acw/"><code>acw</code></a>. For reference, see the section <a href="../../acw/">Model-Free Timescale Estimation</a>. <code>acw</code> offers quite a number of different ways to estimate timescales. The situation might be confusing for newcomers and even seasoned researchers. INTs had been a part of my life for the last 5 years and even I occasionally find myself unsure on what to do. As experimental researchers, we do not have the luxury of a ground truth that we can use to validate our estimations. If we had, we would not need to estimate anything in the first place. The best we can do is to compare our results to the simulations where the ground truth is known, literature and theory. I believe that experimental researchers are entitled to look at computational researchers and package developers and ask them &quot;Okay, this is all well and good but what I <em>should</em> do?&quot;. The problem is, there is almost never a gold standard / best practice that we can use and get the best results. Therefore I opted to avoid recommending one. Nonetheless, there are certain rules of thumb and certain things to <em>not</em> do. The purpose of this section is to talk about them. </p><p>I should note that this section will not go into detailed discussions about each metric. This is done in the <a href="../../practice/practice_intro/">Practice</a> section. If you are not familiar with the INTs, I would highly recommend you to go through it to build your intuition slowly. The timescales of understanding are unfortunately slow :upside<em>down</em>face:. </p><p>In the function <code>acw</code>, one can set the different methods to use as simply:</p><pre><code class="language-julia hljs">acwresults = acw(data, fs; acwtypes=[:acw0, :acw50, :acweuler, :auc, :tau, :knee])</code></pre><p>Different metrics specified in <code>acwtypes</code> is automatically calculated and returned in <code>acwresults</code>. Below, I&#39;ll try to show you the mental workflow on deciding which metric to use. </p><h2 id="Getting-ACW-0-Out-of-the-Way:"><a class="docs-heading-anchor" href="#Getting-ACW-0-Out-of-the-Way:">Getting ACW-0 Out of the Way:</a><a id="Getting-ACW-0-Out-of-the-Way:-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-ACW-0-Out-of-the-Way:" title="Permalink"></a></h2><p>Never use <code>:acw0</code> in serious research. I considered to not include it in the final package but I know that some people will ask for it anyway. So I decided to put it here but warn against it. There are serious problems with ACW-0. Consider when an exponential decay function <span>$f(x) = e^{\lambda x}$</span> reaches zero. There are two cases here. In the first case <span>$\lambda$</span> is a real number. This is the pure exponential decay function without oscillations we usually encounter in fMRI or calcium imaging (after averaging over channels). In this case, <span>$f(x)$</span> never touches zero. You might protest this suggestion by saying &quot;but look, in my data I plot the ACF and it clearly touches zero&quot;. This is due to finite data bias. In all data, you have this bias and ACW-0 amplifies it. Now let&#39;s consider the second case where <span>$\lambda$</span> is complex. This is the case we deal with usually in EEG / MEG data with oscillatorions. Let $ \lambda = a + bi <span>$, then by Euler&#39;s formula, we have $ f(x) = e^{ax} e^{ibx} = e^{ax} (cos(bx) + i sin (bx) )$</span>. Since our data is real valued, the actual autocorrelation function is the real part of this. Here, the real part of <span>$\lambda$</span>, <span>$\mathscr{R}(\lambda) = a$</span> is the decay rate of the ACF and therefore, the timescale. Now we can ask ourselves when the ACF touches zero. Solving <span>$cos(bx) = 0$</span> for x, we will get x = \frac{\pi}{2b} $. Clearly ACW-0 here does not show the timescale, it just shows the oscillatory artifact. If you are interested in oscillations, that is perfectly fine but there are way better tools for that, such as the Fourier transform. This is the case when you have long data. In the case of smaller data, finite data bias might beat oscillatory artifacts. Now there is one more case I haven&#39;t talked about: multiple oscillations in ACF. But it is clear that that will suffer from the same problem. I used to think ACW-0 is justified in data with very low sampling rate, such as fMRI, but area under the curve (<code>:auc</code>) and estimating the decay rate directly (<code>:tau</code>) especially with the option <code>skip_first_lag = true</code> are much better methods. Seriously, I can tell you horror stories about ACW-0. Stay away from it if you don&#39;t know what you are doing. </p><h2 id="ACF-vs-PSD-based-methods"><a class="docs-heading-anchor" href="#ACF-vs-PSD-based-methods">ACF vs PSD based methods</a><a id="ACF-vs-PSD-based-methods-1"></a><a class="docs-heading-anchor-permalink" href="#ACF-vs-PSD-based-methods" title="Permalink"></a></h2><p>With that out of the way, we face three branches: 1) ACF based methods which do not involve fitting (<code>:acw50</code>, <code>:acweuler</code>, <code>:auc</code>), 2) ACF based methods which do involve fitting (<code>:tau</code>) and 3) PSD based methods (<code>:knee</code>). I would recommend looking at the PSDs and ACFs to decide whether to use ACF or PSD based methods. Here is a quick example:</p><pre><code class="language-julia hljs">using IntrinsicTimescales
using Plots
using Random

tau = 0.5
f = 10.0
oscillation_coefficient = 0.9
duration = 10.0
dt = 1 / 1000.0
data_mean = 0.0
data_sd = 1.0
n_trials = 30

# For reproducibility
seed = 666
rng = Xoshiro(seed)

data = generate_ou_with_oscillation([tau, f, oscillation_coefficient], dt, duration, n_trials, data_mean, data_sd, rng=rng, deq_seed=seed)

acwresults = acw(data, 1 / dt; acwtypes=[:acweuler, :knee], average_over_trials=true)
p = acwplot(acwresults)
title!(p[1], &quot;Big oscillation, timescale from ACF: $(round(acwresults.acw_results[1], digits=3))&quot;)
title!(p[2], &quot;timescale from PSD: $(round(acwresults.acw_results[2], digits=3))&quot;)

oscillation_coefficient_2 = 0.99
data_2 = generate_ou_with_oscillation([tau, f, oscillation_coefficient_2], dt, duration, n_trials, data_mean, data_sd, rng=rng, deq_seed=seed)
acwresults_2 = acw(data_2, 1 / dt; acwtypes=[:acweuler, :knee], average_over_trials=true)
p2 = acwplot(acwresults_2)
title!(p2[1], &quot;Small oscillation, timescale from ACF: $(round(acwresults_2.acw_results[1], digits=3))&quot;)
title!(p2[2], &quot;timescale from PSD: $(round(acwresults_2.acw_results[2], digits=3))&quot;)


data_3 = generate_ou_process(tau, data_sd, dt, duration, n_trials, rng=rng, deq_seed=seed)
acwresults_3 = acw(data_3, 1 / dt; acwtypes=[:acweuler, :knee], average_over_trials=true)
p3 = acwplot(acwresults_3)
title!(p3[1], &quot;No oscillation, timescale from ACF: $(round(acwresults_3.acw_results[1], digits=3))&quot;)
title!(p3[2], &quot;timescale from PSD: $(round(acwresults_3.acw_results[2], digits=3))&quot;)

plot(p, p2, p3, layout=(3, 1), size=(900, 600))
</code></pre><p><img src="../assets/oscillation_comparison.svg" alt="ACW Plots"/></p><p>We can see that in the case of strong oscillations, the PSD based method (<code>:knee</code>) performs better. In the cases of no oscillation (which is usually the case in fMRI data), it doesn&#39;t matter which metric to use. This gives the impression that we should always use <code>:knee</code> no matter the scenario. The simulations give this impression but empirical data can be tricky. I&#39;ve had cases where the PSD based method failed to converge or gave negative timescales. My advice would be to look at the PSDs and see if the estimated knee frequency (indicated with a vertical line) looks okay. </p><p>The bottom line is that there is no one-size-fits-all method. It all depends on the data. A good practice is to use multiple metrics and see if they both give the same empirical result and when writing your paper, reporting one of them in the supplementary material. Reviewers these days often ask for this anyway. One advantage of IntrinsicTimescales.jl is that it makes it very easy to do that. </p><p>Then on the question of <code>:acweuler</code> and <code>:acw50</code>: for the most part it doesn&#39;t really matter. In my experience they almost always very highly correlate, to the degree that they are interchangable. Note that if the ACF fits an exponential decay function very well, <code>:acweuler</code> directly gives the inverse decay rate of ACF whereas <code>:acw50</code> gives the inverse decay rate up to a constant (which happens to be <span>$log{2}$</span>). </p><h2 id=":tau-vs-:acw*"><a class="docs-heading-anchor" href="#:tau-vs-:acw*"><code>:tau</code> vs <code>:acw*</code></a><a id=":tau-vs-:acw*-1"></a><a class="docs-heading-anchor-permalink" href="#:tau-vs-:acw*" title="Permalink"></a></h2><p>In the case where sampling rate is very low (fMRI data, certain calcium imaging data) <code>:tau</code> works much better. The reason is that in the case where the decay rate of ACF is faster than the sampling rate, the temporal resolution of ACF (which has the same temporal resolution as your time-series data) can&#39;t catch up with the decay and in practice you end up in every ROI / subject showing an ACW of 1-2 lags (with occasional rare exception of 4-5 lags). In the case of super-low sampling rate (fMRI) I can also recommend setting the option <code>skip_zero_lag=true</code>. </p><h2 id="When-to-use-:auc?"><a class="docs-heading-anchor" href="#When-to-use-:auc?">When to use <code>:auc</code>?</a><a id="When-to-use-:auc?-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-:auc?" title="Permalink"></a></h2><p>For low sampling rates, for example, fMRI. Regarding <code>:tau</code> versus <code>:auc</code>, I prefer <code>:tau</code> with <code>skip_zero_lag=true</code> but that&#39;s my personal preference. I&#39;m writing up a short piece on this which I&#39;ll put to this documentation soon. You can see two very good papers using these approaches in <a href="https://www.sciencedirect.com/science/article/pii/S1053811920306273">Ito et al., 2020</a> (using <code>:tau</code> with <code>skip_zero_lag=true</code>) and <a href="https://elifesciences.org/articles/75540">Manea et al., 2022</a> (using <code>:auc</code>). </p><h2 id="Should-I-average_over_trials?"><a class="docs-heading-anchor" href="#Should-I-average_over_trials?">Should I <code>average_over_trials</code>?</a><a id="Should-I-average_over_trials?-1"></a><a class="docs-heading-anchor-permalink" href="#Should-I-average_over_trials?" title="Permalink"></a></h2><p>In general, yes. In my experience, averaging ACFs or PSDs and then estimating the timescale (which is what <code>average_over_trials</code> does) works much better than estimating one timescale from each trial and averaging over them. If you suspect that there might be a nonstationarity in your timescales (i.e. your timescales change over time), you can investigate timescales in each trial by setting <code>average_over_trials</code> off. Needless to say, this depends on having trials, which means you should not use this if you have, say, one long fMRI recording. </p><h2 id="Should-I-skip_zero_lag?"><a class="docs-heading-anchor" href="#Should-I-skip_zero_lag?">Should I <code>skip_zero_lag</code>?</a><a id="Should-I-skip_zero_lag?-1"></a><a class="docs-heading-anchor-permalink" href="#Should-I-skip_zero_lag?" title="Permalink"></a></h2><p>Yes for fMRI, no for EEG / MEG. </p><h2 id="Should-I-allow_variable_exponent?"><a class="docs-heading-anchor" href="#Should-I-allow_variable_exponent?">Should I <code>allow_variable_exponent</code>?</a><a id="Should-I-allow_variable_exponent?-1"></a><a class="docs-heading-anchor-permalink" href="#Should-I-allow_variable_exponent?" title="Permalink"></a></h2><p>This is an engineering problem. If we allow variable exponent, we are adding one more parameter to estimate which makes the fitting more difficult and in practice, most EEG / MEG spectra have a power law exponent of approximately 2. But in the cases where this is not correct, it is necessary to allow variable exponent. My recommendation is to plot the result using <code>acwplot</code> and see if the knee frequency is correctly estimated (check vertical line) visually. In the next version of IntrinsicTimescales.jl (v0.6.0), I&#39;ll add more diagnostic plotting capabilities which will make this process much smoother. Meanwhile also consider using the python package <a href="https://fooof-tools.github.io/fooof/">FOOOF</a> which is not a general INT toolbox but can estimate INTs using the knee frequency method. In fact, the <code>:knee</code> option in IntrinsicTimescales.jl is trying to mimic FOOOF package&#39;s behavior, with slight differences (e.g. using SciML environment as opposed to SciPy). </p><h2 id="Should-I-set-constrainedtrue?"><a class="docs-heading-anchor" href="#Should-I-set-constrainedtrue?">Should I set <code>constrained=true</code>?</a><a id="Should-I-set-constrainedtrue?-1"></a><a class="docs-heading-anchor-permalink" href="#Should-I-set-constrainedtrue?" title="Permalink"></a></h2><p>In certain cases it might be beneficial to set <code>constrained</code> to <code>true</code> for <code>:knee</code>. This effectively sets bounds on the values each parameter can take. But in my experience, NonlinearSolve.jl (which is the engine behind <code>constrained=false</code>) performs better than Optimization.jl (which is used when <code>constrained=true</code>) (note that this is entirely anecdotal). Furthermore, if the fitting is problematic and gives unreasonable results (such as negative timescales), I would first look at the PSDs to see if they are indeed Lorentzian shaped (i.e. in the log-log space they start out as a flat line and then decay with a slope of -2). Most of the time, computational problems are actually model problems, in the sense of using the wrong model (see <a href="https://statmodeling.stat.columbia.edu/2008/05/13/the_folk_theore/">Folk Theorem of Statistical Computing</a>). </p><p>Some practical advices in this case: 1) <code>average_over_trials</code> if you haven&#39;t done so. This results in a smoother PSD which is more amenable to fitting. 2) Check your lower frequency limit in the PSD. Remember that your PSD should look like a Lorentzian, the low frequency section should be flat. If the full PSD is just a line (i.e. scale-free), <code>:knee</code> can not be used. 3) Check the length of each of your trials. Let&#39;s assume that during the preprocessing stage you applied a high-pass filter of 1 Hz. As a rule of thumb, you should contain at least 3 cycles of the lowest frequency in your data for each trial. This means that you should have at least 3 seconds of data in each trial. Nonetheless, it will still be quite noisy. I suggest at least 10 seconds per trial. If your timescale is at, say, 3 Hz and your data is only 1 second, you will barely see the knee frequency in your PSD and wrongly conclude that your data is scale-free. </p><h2 id="Should-I-use-paralleltrue?"><a class="docs-heading-anchor" href="#Should-I-use-paralleltrue?">Should I use <code>parallel=true</code>?</a><a id="Should-I-use-paralleltrue?-1"></a><a class="docs-heading-anchor-permalink" href="#Should-I-use-paralleltrue?" title="Permalink"></a></h2><p>Depends on the size of your data. If you have a multi-core machine, it might speed up the computation significantly. But if your data is small, the overhead of parallelization might actually slow down the computation. You can see the number of threads by running <code>Threads.nthreads()</code>. If it is 1, you are not using parallelization. To start Julia with multiple threads (say, 4), you can either run <code>julia -t 4</code> or set the environment variable <code>JULIA_NUM_THREADS=4</code>. In VsCode, you can set the environment variable by going to <code>File</code> -&gt; <code>Preferences</code> -&gt; <code>Settings</code> -&gt; <code>Julia: Num Threads</code> and setting to the number of threads you want to use. </p><h2 id="When-to-use-Bayesian-methods?"><a class="docs-heading-anchor" href="#When-to-use-Bayesian-methods?">When to use Bayesian methods?</a><a id="When-to-use-Bayesian-methods?-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-use-Bayesian-methods?" title="Permalink"></a></h2><p>Bayesian methods are very novel and experimental. They can work terrificly good especially in the case of short data and missing samples. But they come at a cost of significantly increased computation time. I would consider them in cutting-edge research, for example, an experimental scenario where you have to compare timescales of two different conditions with different trial lengths (standard ACF / PSD based methods can be sensitive to data length). In any case, don&#39;t forget to do posterior predictive check if you are using Bayesian methods. </p><h2 id="Can-I-calculate-INTs-in-task-trials-(ERP/ERF/ASSR-and-so-on)?"><a class="docs-heading-anchor" href="#Can-I-calculate-INTs-in-task-trials-(ERP/ERF/ASSR-and-so-on)?">Can I calculate INTs in task trials (ERP/ERF/ASSR and so on)?</a><a id="Can-I-calculate-INTs-in-task-trials-(ERP/ERF/ASSR-and-so-on)?-1"></a><a class="docs-heading-anchor-permalink" href="#Can-I-calculate-INTs-in-task-trials-(ERP/ERF/ASSR-and-so-on)?" title="Permalink"></a></h2><p>No. Both ACF and PSD assume stationarity. Task trials are nonstationary (i.e. the signal&#39;s mean value is changing over time). I would recommend calculating INTs only in resting state or continuous tasks such as listening to a story or some continuous behavioral tasks (see <a href="https://elifesciences.org/articles/75540">Manea et al., 2022</a> or <a href="https://www.nature.com/articles/s42003-024-07349-1">Çatal et al., 2024</a>). </p><h2 id="TL;DR"><a class="docs-heading-anchor" href="#TL;DR">TL;DR</a><a id="TL;DR-1"></a><a class="docs-heading-anchor-permalink" href="#TL;DR" title="Permalink"></a></h2><ul><li>Don&#39;t use ACW-0 for anything serious.</li><li>There is no one-size-fits-all method. Experiment with different measures and most importantly, look at your data. </li><li>If there are strong oscillatory components in your PSD, consider using <code>:knee</code>.</li><li>If your sampling rate is very low (fMRI), consider using <code>:tau</code> with <code>skip_zero_lag</code> or <code>:auc</code>.</li><li>If you have trials, <code>average_over_trials</code>. </li><li>If your knee frequencies are at the wrong place after visual inspection, consider using <code>allow_variable_exponent</code>. </li><li>Look at your PSD before setting <code>constrained=true</code>. </li><li>If you are considering using Bayesian methods, make sure to check the posteriors. </li><li>Calculate INTs only in stationary data. </li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/theory/">« Theory</a><a class="docs-footer-nextpage" href="../../acw/">Model-Free Timescale Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 19 June 2025 14:06">Thursday 19 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
