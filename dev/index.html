<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · IntrinsicTimescales.jl</title><meta name="title" content="API · IntrinsicTimescales.jl"/><meta property="og:title" content="API · IntrinsicTimescales.jl"/><meta property="twitter:title" content="API · IntrinsicTimescales.jl"/><meta name="description" content="Documentation for IntrinsicTimescales.jl."/><meta property="og:description" content="Documentation for IntrinsicTimescales.jl."/><meta property="twitter:description" content="Documentation for IntrinsicTimescales.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="home/">IntrinsicTimescales.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="home/">Getting Started</a></li><li><span class="tocitem">Practice</span><ul><li><a class="tocitem" href="practice/practice_intro/">Practice</a></li><li><a class="tocitem" href="practice/practice_1_acf/">Building the Autocorrelation Function</a></li><li><a class="tocitem" href="practice/practice_2_acw/">Autocorrelation Windows</a></li><li><a class="tocitem" href="practice/practice_3_ou/">Ornstein-Uhlenbeck Process as a Generative Model for ACF</a></li><li><a class="tocitem" href="practice/practice_4_psd/">Dealing with Oscillatory Artifacts using Fourier Transformation</a></li><li><a class="tocitem" href="practice/practice_5_bayesian/">Bayesian Estimation of Intrinsic Timescales</a></li></ul></li><li><a class="tocitem" href="theory/theory/">Theory</a></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="acw/">Model-Free Timescale Estimation</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Simulation Based Timescale Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="simbasedinference/">Overview</a></li><li><a class="tocitem" href="one_timescale/">One Timescale Model</a></li><li><a class="tocitem" href="one_timescale_with_missing/">One Timescale Model with Missing Data</a></li><li><a class="tocitem" href="one_timescale_and_osc/">One Timescale Model with Oscillations</a></li><li><a class="tocitem" href="one_timescale_and_osc_with_missing/">One Timescale Model with Oscillations and Missing Data</a></li><li><a class="tocitem" href="fit_parameters/">Model Fitting and Parameters</a></li><li><a class="tocitem" href="fit_result/">Results</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.IntrinsicTimescales" href="#IntrinsicTimescales.IntrinsicTimescales"><code>IntrinsicTimescales.IntrinsicTimescales</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IntrinsicTimescales</code></pre><p>A Julia package for estimation of timescales from time series data.</p><p><strong>Features</strong></p><ul><li>Standard techniques for INT calculation: ACW-50, ACW-0, FOOOF</li><li>Approximate Bayesian Computation (ABC) for parameter inference</li><li>ADVI for variational inference</li><li>Multiple model types:<ul><li>Single timescale</li><li>Single timescale with oscillations</li><li>Models supporting missing data</li></ul></li><li>Summary statistics using periodogram, Welch (from DSP.jl) and Lomb-Scargle (from LombScargle.jl):<ul><li>Autocorrelation function (ACF)</li><li>Power spectral density (PSD)</li></ul></li></ul><p><strong>Submodules</strong></p><ul><li><code>Models</code>: Abstract model types and interfaces</li><li><code>ABC</code>: Approximate Bayesian Computation algorithms</li><li><code>TuringBackend</code>: Turing.jl integration for ADVI</li><li><code>SummaryStats</code>: ACF and PSD implementations</li><li><code>Distances</code>: Distance metrics for ABC</li><li><code>Utils</code>: Utility functions for analysis</li><li><code>OrnsteinUhlenbeck</code>: OU process generation using DifferentialEquations.jl</li><li><code>OneTimescale</code>: Single timescale model</li><li><code>OneTimescaleAndOsc</code>: Single timescale with oscillations</li><li><code>OneTimescaleWithMissing</code>: Single timescale with missing data</li><li><code>OneTimescaleAndOscWithMissing</code>: Single timescale and oscillations with missing data</li><li><code>Plotting</code>: Plotting functions for results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/IntrinsicTimescales.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.AbstractTimescaleModel" href="#IntrinsicTimescales.Models.AbstractTimescaleModel"><code>IntrinsicTimescales.Models.AbstractTimescaleModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTimescaleModel</code></pre><p>Abstract type representing models for timescale inference. All concrete model implementations should subtype this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.BaseModel" href="#IntrinsicTimescales.Models.BaseModel"><code>IntrinsicTimescales.Models.BaseModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaseModel &lt;: AbstractTimescaleModel</code></pre><p>Base model structure for timescale inference using various methods.</p><p><strong>Fields</strong></p><ul><li><code>data</code>: Input time series data</li><li><code>time</code>: Time points corresponding to the data</li><li><code>data_sum_stats</code>: Pre-computed summary statistics of the data</li><li><code>fitmethod::Symbol</code>: Fitting method to use. Options: <code>:abc</code>, <code>:advi</code>, <code>:acw</code></li><li><code>summary_method::Symbol</code>: Summary statistic type. Options: <code>:psd</code> (power spectral density) or <code>:acf</code> (autocorrelation)</li><li><code>lags_freqs::AbstractVector{&lt;:Real}</code>: Lags (for ACF) or frequencies (for PSD) at which to compute summary statistics</li><li><code>prior</code>: Prior distributions for parameters. Can be Vector{Distribution}, single Distribution, or &quot;informed_prior&quot;</li><li><code>acwtypes::Union{Vector{Symbol}, Symbol}</code>: ACW analysis types (e.g., :ACW50, :ACW0, :ACWe, :tau, :knee)</li><li><code>distance_method::Symbol</code>: Distance metric type. Options: <code>:linear</code> or <code>:logarithmic</code></li><li><code>dt::Real</code>: Time step between observations</li><li><code>T::Real</code>: Total time span of the data</li><li><code>numTrials::Real</code>: Number of trials/iterations</li><li><code>data_mean::Real</code>: Mean of the input data</li><li><code>data_sd::Real</code>: Standard deviation of the input data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.check_acwtypes-Tuple{Any, Any}" href="#IntrinsicTimescales.Models.check_acwtypes-Tuple{Any, Any}"><code>IntrinsicTimescales.Models.check_acwtypes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_acwtypes(acwtypes, possible_acwtypes)</code></pre><p>Validate the ACW analysis types against allowed options.</p><p><strong>Arguments</strong></p><ul><li><code>acwtypes</code>: Symbol or Vector of Symbols specifying ACW analysis types</li><li><code>possible_acwtypes</code>: Vector of allowed ACW analysis types</li></ul><p><strong>Returns</strong></p><ul><li>Validated vector of ACW types</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If invalid ACW types are provided</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L197-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.check_inputs-Tuple{Any, Any}" href="#IntrinsicTimescales.Models.check_inputs-Tuple{Any, Any}"><code>IntrinsicTimescales.Models.check_inputs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_inputs(fitmethod, summary_method)</code></pre><p>Validate the fitting method and summary statistic choices.</p><p><strong>Arguments</strong></p><ul><li><code>fitmethod</code>: Symbol specifying the fitting method</li><li><code>summary_method</code>: Symbol specifying the summary statistic type</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If invalid options are provided</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L175-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.check_model_inputs" href="#IntrinsicTimescales.Models.check_model_inputs"><code>IntrinsicTimescales.Models.check_model_inputs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_model_inputs(data, time, fit_method, summary_method, prior, acwtypes, distance_method)</code></pre><p>Validate inputs for timescale model construction.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input time series data</li><li><code>time</code>: Time points corresponding to the data</li><li><code>fit_method</code>: Fitting method (:abc, :advi)</li><li><code>summary_method</code>: Summary statistic type (:psd or :acf)</li><li><code>prior</code>: Prior distribution(s) for parameters</li><li><code>acwtypes</code>: Types of ACW analysis</li><li><code>distance_method</code>: Distance metric type (:linear or :logarithmic)</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If any inputs are invalid or incompatible</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L222-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.distance_function" href="#IntrinsicTimescales.Models.distance_function"><code>IntrinsicTimescales.Models.distance_function</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_function(model::AbstractTimescaleModel, summary_stats, summary_stats_synth)</code></pre><p>Compute distance between two sets of summary statistics.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance</li><li><code>summary_stats</code>: First set of summary statistics</li><li><code>summary_stats_synth</code>: Second set of summary statistics (typically from synthetic data)</li></ul><p><strong>Returns</strong></p><ul><li>Distance value according to model.distance_method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L93-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.draw_theta" href="#IntrinsicTimescales.Models.draw_theta"><code>IntrinsicTimescales.Models.draw_theta</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_theta(model::AbstractTimescaleModel)</code></pre><p>Draw parameter values from the model&#39;s prior distributions.</p><p><strong>Returns</strong></p><ul><li>Array of proposed model parameters sampled from their respective priors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L55-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data" href="#IntrinsicTimescales.Models.generate_data"><code>IntrinsicTimescales.Models.generate_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_data(model::AbstractTimescaleModel, theta)</code></pre><p>Generate synthetic data using the forward model with given parameters.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance</li><li><code>theta</code>: Array of model parameters</li></ul><p><strong>Returns</strong></p><ul><li>Synthetic dataset with same structure as the original data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data_and_reduce-Tuple{AbstractTimescaleModel, Any}" href="#IntrinsicTimescales.Models.generate_data_and_reduce-Tuple{AbstractTimescaleModel, Any}"><code>IntrinsicTimescales.Models.generate_data_and_reduce</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_data_and_reduce(model::AbstractTimescaleModel, theta)</code></pre><p>Combined function to generate synthetic data and compute distance from observed data. This is a convenience function commonly used in ABC algorithms.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance</li><li><code>theta</code>: Array of model parameters</li></ul><p><strong>Returns</strong></p><ul><li>Distance value between synthetic and observed summary statistics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L133-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.int_fit" href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit(model::AbstractTimescaleModel, param_dict=nothing)</code></pre><p>Fit the timescale model using the specified fitting method.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: The timescale model instance to fit</li><li><code>param_dict</code>: Optional dictionary of fitting parameters. If not provided, default parameters will be used.</li></ul><p><strong>Returns</strong></p><p>For ADVI fitting method:</p><ul><li><code>samples</code>: Array of posterior samples</li><li><code>map_estimate</code>: Maximum a posteriori estimate of parameters</li><li><code>vi_result</code>: Full variational inference result object</li></ul><p>For ABC fitting method:</p><ul><li><code>samples</code>: Array of accepted parameter samples</li><li><code>weights</code>: Importance weights for the samples</li><li><code>distances</code>: Distances between simulated and observed summary statistics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L110-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.summary_stats" href="#IntrinsicTimescales.Models.summary_stats"><code>IntrinsicTimescales.Models.summary_stats</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summary_stats(model::AbstractTimescaleModel, data)</code></pre><p>Compute summary statistics (PSD or ACF) from the data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance</li><li><code>data</code>: Input data (original or synthetic)</li></ul><p><strong>Returns</strong></p><ul><li>Array of summary statistics computed according to model.summary_method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/model.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.ABCResults" href="#IntrinsicTimescales.ABC.ABCResults"><code>IntrinsicTimescales.ABC.ABCResults</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ABCResults</code></pre><p>Container for ABC results to standardize plotting interface.</p><p><strong>Fields</strong></p><ul><li><code>theta_history::Vector{Matrix{Float64}}</code>: History of parameter values across iterations</li><li><code>epsilon_history::Vector{Float64}</code>: History of epsilon values</li><li><code>acc_rate_history::Vector{Float64}</code>: History of acceptance rates</li><li><code>weights_history::Vector{Vector{Float64}}</code>: History of weights</li><li><code>final_theta::Matrix{Float64}</code>: Final accepted parameter values</li><li><code>final_weights::Vector{Float64}</code>: Final weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L20-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.abc_results-Tuple{Vector{NamedTuple}}" href="#IntrinsicTimescales.ABC.abc_results-Tuple{Vector{NamedTuple}}"><code>IntrinsicTimescales.ABC.abc_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abc_results(output_record::Vector{NamedTuple})</code></pre><p>Construct abc_results from PMC-ABC output record.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.basic_abc-Tuple{AbstractTimescaleModel}" href="#IntrinsicTimescales.ABC.basic_abc-Tuple{AbstractTimescaleModel}"><code>IntrinsicTimescales.ABC.basic_abc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basic_abc(model::Models.AbstractTimescaleModel; kwargs...)</code></pre><p>Perform basic ABC rejection sampling.</p><p><strong>Arguments</strong></p><ul><li><code>model::Models.AbstractTimescaleModel</code>: Model to perform inference on</li><li><code>epsilon::Float64</code>: Acceptance threshold</li><li><code>max_iter::Integer</code>: Maximum number of iterations</li><li><code>min_accepted::Integer</code>: Minimum number of accepted samples required</li><li><code>pmc_mode::Bool=false</code>: Whether to use PMC proposal distribution</li><li><code>weights=Array{Float64}</code>: Importance weights (used in PMC mode)</li><li><code>theta_prev=Array{Float64}</code>: Previous parameters (used in PMC mode)</li><li><code>tau_squared=Array{Float64}</code>: Covariance matrix (used in PMC mode)</li><li><code>show_progress::Bool=true</code>: Whether to show progress bar</li></ul><p><strong>Returns</strong></p><p>NamedTuple containing:</p><ul><li><code>samples</code>: All proposed parameters</li><li><code>isaccepted</code>: Boolean mask of accepted samples</li><li><code>theta_accepted</code>: Accepted parameters</li><li><code>distances</code>: Distances for all proposals</li><li><code>n_accepted</code>: Number of accepted samples</li><li><code>n_total</code>: Total number of iterations</li><li><code>epsilon</code>: Acceptance threshold used</li><li><code>weights</code>: Sample weights (uniform in basic ABC)</li><li><code>tau_squared</code>: Covariance matrix (zeros in basic ABC)</li><li><code>eff_sample</code>: Effective sample size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L106-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.calc_weights-Tuple{VecOrMat{Float64}, VecOrMat{Float64}, Matrix{Float64}, Vector{Float64}, Union{Distributions.Distribution, Vector}}" href="#IntrinsicTimescales.ABC.calc_weights-Tuple{VecOrMat{Float64}, VecOrMat{Float64}, Matrix{Float64}, Vector{Float64}, Union{Distributions.Distribution, Vector}}"><code>IntrinsicTimescales.ABC.calc_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_weights(theta_prev, theta, tau_squared, weights, prior)</code></pre><p>Calculate importance weights for PMC-ABC algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>theta_prev</code>: Previously accepted parameters</li><li><code>theta</code>: Current parameters</li><li><code>tau_squared</code>: Covariance matrix for proposal distribution</li><li><code>weights</code>: Previous importance weights</li><li><code>prior</code>: Prior distribution(s)</li></ul><p><strong>Returns</strong></p><ul><li>Vector of normalized importance weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L438-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.compute_adaptive_alpha-Tuple{Integer, Float64, Float64}" href="#IntrinsicTimescales.ABC.compute_adaptive_alpha-Tuple{Integer, Float64, Float64}"><code>IntrinsicTimescales.ABC.compute_adaptive_alpha</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compute adaptive alpha value based on iteration and convergence metrics</p><p><strong>Arguments</strong></p><ul><li><code>iteration</code>: Current iteration number</li><li><code>current_acc_rate</code>: Current acceptance rate</li><li><code>target_acc_rate</code>: Target acceptance rate</li><li><code>alpha_max</code>: Maximum alpha value (default: 0.9)</li><li><code>alpha_min</code>: Minimum alpha value (default: 0.1)</li><li><code>total_iterations</code>: Total number of iterations</li><li><code>acc_rate_far</code>: Threshold for &quot;far from target&quot; adjustment (default: 2.0)</li><li><code>acc_rate_close</code>: Threshold for &quot;close to target&quot; adjustment (default: 0.2)</li><li><code>alpha_far_mult</code>: Multiplier for alpha when far from target (default: 1.5)</li><li><code>alpha_close_mult</code>: Multiplier for alpha when close to target (default: 0.5)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L649-L663">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.draw_theta_pmc-NTuple{4, Any}" href="#IntrinsicTimescales.ABC.draw_theta_pmc-NTuple{4, Any}"><code>IntrinsicTimescales.ABC.draw_theta_pmc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw_theta_pmc(model, theta_prev, weights, tau_squared; jitter::Float64=1e-5)</code></pre><p>Draw new parameter values using the PMC proposal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance</li><li><code>theta_prev</code>: Previously accepted parameters</li><li><code>weights</code>: Importance weights from previous iteration</li><li><code>tau_squared</code>: Covariance matrix for proposal distribution</li><li><code>jitter::Float64=1e-5</code>: Small value added to covariance diagonal for numerical stability</li></ul><p><strong>Returns</strong></p><ul><li>Vector of proposed parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L73-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.effective_sample_size-Tuple{Vector{Float64}}" href="#IntrinsicTimescales.ABC.effective_sample_size-Tuple{Vector{Float64}}"><code>IntrinsicTimescales.ABC.effective_sample_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">effective_sample_size(w::Vector{Float64})</code></pre><p>Calculate effective sample size from importance weights.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: Vector of importance sampling weights</li></ul><p><strong>Returns</strong></p><ul><li>Float64: Effective sample size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L547-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.find_MAP" href="#IntrinsicTimescales.ABC.find_MAP"><code>IntrinsicTimescales.ABC.find_MAP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_MAP(theta_accepted::Matrix{Float64}, N::Int)</code></pre><p>Find the MAP estimates from posteriors with grid search.</p><p><strong>Arguments</strong></p><ul><li><code>theta_accepted::Matrix{Float64}</code>: Matrix of accepted samples from the final step of ABC</li><li><code>N::Int</code>: Number of samples for grid search</li></ul><p><strong>Returns</strong></p><ul><li><code>theta_map::Vector{Float64}</code>: MAP estimates of the parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L696-L707">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.get_param_dict_abc-Tuple{}" href="#IntrinsicTimescales.ABC.get_param_dict_abc-Tuple{}"><code>IntrinsicTimescales.ABC.get_param_dict_abc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_param_dict_abc()</code></pre><p>Get default parameter dictionary for ABC algorithm.</p><p><strong>Returns</strong></p><p>Dictionary containing default values for all ABC parameters including:</p><ul><li>Basic ABC parameters (epsilon<em>0, max</em>iter, etc.)</li><li>Acceptance rate parameters</li><li>Display parameters</li><li>Numerical stability parameters</li><li>Epsilon selection parameters</li><li>Adaptive alpha parameters</li><li>Early stopping parameters</li><li>MAP estimation parameters</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L731-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.pmc_abc-Tuple{AbstractTimescaleModel}" href="#IntrinsicTimescales.ABC.pmc_abc-Tuple{AbstractTimescaleModel}"><code>IntrinsicTimescales.ABC.pmc_abc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pmc_abc(model::Models.AbstractTimescaleModel; epsilon_0=1.0, max_iter=10000, min_accepted=100, steps=10, sample_only=false, minAccRate=0.01, target_acc_rate=0.01)</code></pre><p>Perform Population Monte Carlo Approximate Bayesian Computation (PMC-ABC) inference.</p><p><strong>Arguments</strong></p><ul><li><code>model::Models.AbstractTimescaleModel</code>: Model to perform inference on</li><li><code>epsilon_0::Float64=1.0</code>: Initial epsilon threshold for acceptance</li><li><code>max_iter::Int=10000</code>: Maximum number of iterations per step</li><li><code>min_accepted::Int=100</code>: Minimum number of accepted samples required</li><li><code>steps::Int=10</code>: Number of PMC steps to perform</li><li><code>sample_only::Bool=false</code>: If true, only perform sampling without adaptation</li><li><code>minAccRate::Float64=0.01</code>: Minimum acceptance rate before stopping</li><li><code>target_acc_rate::Float64=0.01</code>: Target acceptance rate for epsilon adaptation</li></ul><p><strong>Returns</strong></p><p>Vector of NamedTuples containing results for each PMC step, including:</p><ul><li>Accepted parameters (theta_accepted)</li><li>Distances (D_accepted) </li><li>Number of accepted/total samples</li><li>Epsilon threshold</li><li>Sample weights</li><li>Covariance matrix (tau_squared)</li><li>Effective sample size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L196-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.select_epsilon-Tuple{Vector{Float64}, Float64}" href="#IntrinsicTimescales.ABC.select_epsilon-Tuple{Vector{Float64}, Float64}"><code>IntrinsicTimescales.ABC.select_epsilon</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Adaptively selects epsilon based on acceptance rate and distance distribution</p><p><strong>Arguments</strong></p><ul><li><code>distances</code>: Vector of distances from ABC</li><li><code>current_epsilon</code>: Current epsilon value</li><li><code>target_acc_rate</code>: Target acceptance rate</li><li><code>current_acc_rate</code>: Current acceptance rate</li><li><code>iteration</code>: Current iteration number</li><li><code>total_iterations</code>: Total number of iterations</li><li><code>distance_max</code>: Maximum distance to consider valid (default: 10.0)</li><li><code>quantile_lower</code>: Lower quantile for epsilon adjustment (default: 25)</li><li><code>quantile_upper</code>: Upper quantile for epsilon adjustment (default: 75)</li><li><code>quantile_init</code>: Initial quantile when no acceptance rate (default: 50)</li><li><code>acc_rate_buffer</code>: Buffer around target acceptance rate (default: 0.1)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L570-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ABC.weighted_covar-Tuple{Matrix{Float64}, Vector{Float64}}" href="#IntrinsicTimescales.ABC.weighted_covar-Tuple{Matrix{Float64}, Vector{Float64}}"><code>IntrinsicTimescales.ABC.weighted_covar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weighted_covar(x::Matrix{Float64}, w::Vector{Float64})</code></pre><p>Calculate weighted covariance matrix.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Matrix of values where each row is an observation</li><li><code>w</code>: Vector of weights corresponding to each observation</li></ul><p><strong>Returns</strong></p><ul><li>Weighted covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/abc.jl#L502-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ACW" href="#IntrinsicTimescales.ACW"><code>IntrinsicTimescales.ACW</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ACW</code></pre><p>Module providing autocorrelation width (ACW) calculations for time series analysis, including:</p><ul><li>ACW-0 (zero-crossing)</li><li>ACW-50 (50% decay)</li><li>ACW-euler (1/e decay)</li><li>Exponential decay timescale (tau)</li><li>Knee frequency estimation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/acw.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ACW.ACWResults" href="#IntrinsicTimescales.ACW.ACWResults"><code>IntrinsicTimescales.ACW.ACWResults</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ACWResults</code></pre><p>Structure holding ACW analysis inputs and results.</p><p><strong>Fields</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data</li><li><code>fs::Real</code>: Sampling frequency</li><li><code>acwtypes::Union{Vector{&lt;:Symbol}, Symbol, Nothing}</code>: Types of ACW to compute</li><li><code>n_lags::Union{Int, Nothing}</code>: Number of lags for ACF calculation</li><li><code>freqlims::Union{Tuple{Real, Real}, Nothing}</code>: Frequency limits for spectral analysis</li><li><code>acw_results::Vector{&lt;:Real}</code>: Computed ACW values</li></ul><p><strong>Notes</strong></p><ul><li>Supported ACW types: :acw0, :acw50, :acweuler, :tau, :knee</li><li>Results order matches input acwtypes order</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/acw.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.ACW.acw-Tuple{Any, Any}" href="#IntrinsicTimescales.ACW.acw-Tuple{Any, Any}"><code>IntrinsicTimescales.ACW.acw</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acw(data, fs; acwtypes=possible_acwtypes, n_lags=nothing, freqlims=nothing, time=nothing, 
    dims=ndims(data), return_acf=true, return_psd=true, average_over_trials=false,
    trial_dims::Int=setdiff([1, 2], dims)[1], max_peaks::Int=1)</code></pre><p>Compute various autocorrelation width measures for time series data.</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data</li><li><code>fs::Real</code>: Sampling frequency</li><li><code>acwtypes::Union{Vector{Symbol}, Symbol}=possible_acwtypes</code>: Types of ACW to compute</li><li><code>n_lags::Union{Int, Nothing}=nothing</code>: Number of lags for ACF calculation</li><li><code>freqlims::Union{Tuple{Real, Real}, Nothing}=nothing</code>: Frequency limits for spectral analysis</li><li><code>time::Union{Vector{Real}, Nothing}=nothing</code>: Time vector. This is required for Lomb-Scargle method in the case of missing data.</li><li><code>dims::Int=ndims(data)</code>: Dimension along which to compute ACW (Dimension of time)</li><li><code>return_acf::Bool=true</code>: Whether to return the ACF</li><li><code>return_psd::Bool=true</code>: Whether to return the PSD</li><li><code>average_over_trials::Bool=false</code>: Whether to average the ACF or PSD over trials</li><li><code>trial_dims::Int=setdiff([1, 2], dims)[1]</code>: Dimension along which to average the ACF or PSD over trials (Dimension of trials)</li><li><code>max_peaks::Int=1</code>: Maximum number of oscillatory peaks to fit in spectral analysis</li><li><code>oscillation_peak::Bool=true</code>: Whether to fit an oscillation peak in the spectral analysis</li></ul><p><strong>Returns</strong></p><ul><li>Vector of computed ACW measures, ordered according to input acwtypes</li></ul><p><strong>Notes</strong></p><ul><li><p>Supported ACW types:</p><ul><li>:acw0 - Time to first zero crossing</li><li>:acw50 - Time to 50% decay</li><li>:acweuler - Time to 1/e decay</li><li>:tau - Exponential decay timescale</li><li>:knee - Knee frequency from spectral analysis</li></ul></li><li><p>If n_lags is not specified, uses 1.1 * ACW0</p></li><li><p>For spectral measures, freqlims defaults to full frequency range</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/acw.jl#L49-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.TuringBackend.ADVIResults" href="#IntrinsicTimescales.TuringBackend.ADVIResults"><code>IntrinsicTimescales.TuringBackend.ADVIResults</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ADVIResults{T&lt;:Real}</code></pre><p>Container for ADVI (Automatic Differentiation Variational Inference) results.</p><p><strong>Fields</strong></p><ul><li><code>samples::AbstractArray{T}</code>: Matrix of posterior samples</li><li><code>MAP::AbstractVector{T}</code>: Maximum a posteriori estimates</li><li><code>variances::AbstractVector{T}</code>: Posterior variances for each parameter</li><li><code>chain</code>: Turing chain object containing full inference results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/turing_backend.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.TuringBackend.create_turing_model-Tuple{Any, Any}" href="#IntrinsicTimescales.TuringBackend.create_turing_model-Tuple{Any, Any}"><code>IntrinsicTimescales.TuringBackend.create_turing_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_turing_model(model, data_sum_stats; σ_prior=Exponential(1))</code></pre><p>Create a Turing probabilistic model for variational inference.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance containing prior distributions and data generation methods</li><li><code>data_sum_stats</code>: Summary statistics of the observed data</li><li><code>σ_prior=Exponential(1)</code>: Prior distribution for the uncertainty parameter σ</li></ul><p><strong>Returns</strong></p><ul><li>Turing model object ready for inference</li></ul><p><strong>Notes</strong></p><p>The created model includes:</p><ul><li>Parameter sampling from truncated priors (positive values only)</li><li>Data generation using the model&#39;s forward simulation</li><li>Likelihood computation using Normal distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/turing_backend.jl#L27-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.TuringBackend.fit_vi-Tuple{Any}" href="#IntrinsicTimescales.TuringBackend.fit_vi-Tuple{Any}"><code>IntrinsicTimescales.TuringBackend.fit_vi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_vi(model; n_samples=4000, n_iterations=10, n_elbo_samples=20, 
       optimizer=AutoForwardDiff())</code></pre><p>Perform variational inference using ADVI (Automatic Differentiation Variational Inference).</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Model instance to perform inference on</li><li><code>n_samples::Int=4000</code>: Number of posterior samples to draw</li><li><code>n_iterations::Int=10</code>: Number of ADVI iterations</li><li><code>n_elbo_samples::Int=20</code>: Number of samples for ELBO estimation</li><li><code>optimizer=AutoForwardDiff()</code>: Optimization algorithm for ADVI</li></ul><p><strong>Returns</strong></p><ul><li><code>ADVIResults</code>: Container with inference results including:<ul><li>Posterior samples</li><li>MAP estimates</li><li>Parameter variances</li><li>Full Turing chain</li></ul></li></ul><p><strong>Notes</strong></p><p>Uses Turing.jl&#39;s ADVI implementation for fast approximate Bayesian inference. The model is automatically constructed with appropriate priors and likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/turing_backend.jl#L68-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.TuringBackend.get_param_dict_advi-Tuple{}" href="#IntrinsicTimescales.TuringBackend.get_param_dict_advi-Tuple{}"><code>IntrinsicTimescales.TuringBackend.get_param_dict_advi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_param_dict_advi()</code></pre><p>Get default parameter dictionary for ADVI (Automatic Differentiation Variational Inference) algorithm.</p><p><strong>Returns</strong></p><p>Dictionary containing default values for ADVI parameters including:</p><ul><li><code>n_samples</code>: Number of posterior samples to draw (default: 4000)</li><li><code>n_iterations</code>: Number of ADVI iterations (default: 50) </li><li><code>n_elbo_samples</code>: Number of samples for ELBO estimation (default: 20)</li><li><code>autodiff</code>: Automatic differentiation backend (default: AutoForwardDiff())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/turing_backend.jl#L111-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats" href="#IntrinsicTimescales.SummaryStats"><code>IntrinsicTimescales.SummaryStats</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SummaryStats</code></pre><p>Module for computing various summary statistics from time series data. Includes functions for:</p><ul><li>Autocorrelation (FFT and time-domain methods)</li><li>Power spectral density (periodogram and Welch methods)</li><li>Cross-correlation</li><li>Special handling for missing data (NaN values)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats._comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}" href="#IntrinsicTimescales.SummaryStats._comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>IntrinsicTimescales.SummaryStats._comp_psd_lombscargle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_comp_psd_lombscargle(times, data, frequency_grid)</code></pre><p>Internal function to compute Lomb-Scargle periodogram for a single time series.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>: Time points vector (without NaN)</li><li><code>data</code>: Time series data (without NaN)</li><li><code>frequency_grid</code>: Pre-computed frequency grid</li></ul><p><strong>Returns</strong></p><ul><li><code>power</code>: Lomb-Scargle periodogram values</li><li><code>frequency_grid</code>: Input frequency grid</li></ul><p><strong>Notes</strong></p><ul><li>Uses LombScargle.jl for core computation</li><li>Assumes data has been pre-processed and doesn&#39;t contain NaN values</li><li>Normalizes power spectrum by variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L214-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.acf_statsmodels-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.acf_statsmodels-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.acf_statsmodels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acf_statsmodels(x::Vector{T}; kwargs...) where {T &lt;: Real}</code></pre><p>Julia implementation of statsmodels.tsa.stattools.acf function. Only for testing.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Time series data vector</li><li><code>adjusted=false</code>: Use n-k denominators if true</li><li><code>nlags=nothing</code>: Number of lags (default: min(10*log10(n), n-1))</li><li><code>qstat=false</code>: Return Ljung-Box Q-statistics</li><li><code>isfft=false</code>: Use FFT method</li><li><code>alpha=nothing</code>: Confidence level for intervals</li><li><code>bartlett_confint=false</code>: Use Bartlett&#39;s formula</li><li><code>missing_handling=&quot;conservative&quot;</code>: NaN handling method</li></ul><p><strong>Returns</strong></p><ul><li>Vector of autocorrelation values</li></ul><p><strong>Notes</strong></p><ul><li>Supports multiple missing data handling methods:<ul><li>&quot;none&quot;: No checks</li><li>&quot;raise&quot;: Error on NaN</li><li>&quot;conservative&quot;: NaN-aware computations</li><li>&quot;drop&quot;: Remove NaN values</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L451-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.acovf-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.acovf-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.acovf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Estimate autocovariances. Translated to Julia from statsmodels.tsa.stattools</p><p><strong>Parameters</strong></p><p>x : array_like     Time series data. Must be 1d. adjusted : bool, default False     If True, then denominators is n-k, otherwise n. demean : bool, default True     If True, then subtract the mean x from each element of x. fft : bool, default True     If True, use FFT convolution.  This method should be preferred     for long time series. missing : str, default &quot;none&quot;     A string in [&quot;none&quot;, &quot;raise&quot;, &quot;conservative&quot;, &quot;drop&quot;] specifying how     the NaNs are to be treated. &quot;none&quot; performs no checks. &quot;raise&quot; raises     an exception if NaN values are found. &quot;drop&quot; removes the missing     observations and then estimates the autocovariances treating the     non-missing as contiguous. &quot;conservative&quot; computes the autocovariance     using nan-ops so that nans are removed when computing the mean     and cross-products that are used to estimate the autocovariance.     When using &quot;conservative&quot;, n is set to the number of non-missing     observations. nlag : {int, None}, default None     Limit the number of autocovariances returned.  Size of returned     array is nlag + 1.  Setting nlag when fft is False uses a simple,     direct estimator of the autocovariances that only computes the first     nlag + 1 values. This can be much faster when the time series is long     and only a small number of autocovariances are needed.</p><p><strong>Returns</strong></p><p>ndarray     The estimated autocovariances.</p><p><strong>References</strong></p><p>.. [1] Parzen, E., 1963. On spectral analysis with missing observations        and amplitude modulation. Sankhya: The Indian Journal of        Statistics, Series A, pp.383-392.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L502-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.bat_autocorr-Tuple{AbstractVector{&lt;:Real}}" href="#IntrinsicTimescales.SummaryStats.bat_autocorr-Tuple{AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.SummaryStats.bat_autocorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bat_autocorr(x::AbstractVector{&lt;:Real})</code></pre><p>Compute the normalized autocorrelation function of a 1D time series using FFT. Returns a vector containing the autocorrelation values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/bat_autocor.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.bat_autocorr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.bat_autocorr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.bat_autocorr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bat_autocorr(x::AbstractMatrix{&lt;:Real})</code></pre><p>Compute the normalized autocorrelation function of a 2D time series using FFT. data is a matrix with dimensions (n<em>series × n</em>timepoints)</p><p>returns a matrix with dimensions (n<em>series × n</em>lags)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/bat_autocor.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len" href="#IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len"><code>IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bat_integrated_autocorr_len(
    v::AbstractVectorOfSimilarVectors{&lt;:Real};
    c::Integer = 5, tol::Integer = 50, strict = true
)</code></pre><p>Estimate the integrated autocorrelation length of variate series <code>v</code>.</p><ul><li><p><code>c</code>: Step size for window search.</p></li><li><p><code>tol</code>: Minimum number of autocorrelation times needed to trust the estimate.</p></li><li><p><code>strict</code>: Throw exception if result is not trustworthy</p></li></ul><p>This estimate uses the iterative procedure described on page 16 of <a href="http://www.stat.unc.edu/faculty/cji/Sokal.pdf">Sokal&#39;s notes</a> to determine a reasonable window size.</p><p>Ported to Julia from the emcee Python package, under MIT License. Original authors Dan Foreman-Mackey et al.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/bat_autocor.jl#L105-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_weight" href="#IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_weight"><code>IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_weight</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bat_integrated_autocorr_weight(
    samples::DensitySampleVector;
    c::Integer = 5, tol::Integer = 50, strict = true
)</code></pre><p>Estimate the integrated autocorrelation weight of <code>samples</code>.</p><p>Uses <a href="#IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len"><code>bat_integrated_autocorr_len</code></a>.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/bat_autocor.jl#L155-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_ac_fft(data::AbstractArray{T}; dims::Int=ndims(data), n_lags::Integer=size(data, dims)) where {T &lt;: Real}</code></pre><p>Compute autocorrelation using FFT along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Array of time series data</li><li><code>dims</code>: Dimension along which to compute autocorrelation (defaults to last dimension)</li><li><code>n_lags</code>: Number of lags to compute (defaults to size of data along specified dimension)</li></ul><p><strong>Returns</strong></p><p>Array with autocorrelation values, the specified dimension becomes the dimension of lags while the other dimensions denote ACF values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L63-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_fft</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_ac_fft(data::Vector{T}; n_lags::Real=length(data)) where {T &lt;: Real}</code></pre><p>Compute autocorrelation using FFT method.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input time series vector</li><li><code>n_lags</code>: Number of lags to compute (defaults to length of data)</li></ul><p><strong>Returns</strong></p><ul><li>Vector of autocorrelation values from lag 0 to n_lags-1</li></ul><p><strong>Notes</strong></p><ul><li>Uses FFT for efficient computation</li><li>Pads data to next power of 2 for FFT efficiency</li><li>Normalizes by variance (first lag)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L27-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_ac_time-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_ac_time-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_time</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_ac_time(data::AbstractArray{T}, max_lag::Integer; dims::Int=ndims(data)) where {T &lt;: Real}</code></pre><p>Compute autocorrelation in time domain along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Array of time series data</li><li><code>max_lag</code>: Maximum lag to compute</li><li><code>dims</code>: Dimension along which to compute autocorrelation (defaults to last dimension)</li></ul><p><strong>Returns</strong></p><p>Array with autocorrelation values, the specified dimension becomes the dimension of lags while the other dimensions denote ACF values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L370-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_ac_time_missing-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_ac_time_missing-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_time_missing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_ac_time_missing(data::AbstractArray{T}; kwargs...) where {T &lt;: Real}</code></pre><p>Compute autocorrelation for data with missing values.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Time series data (may contain NaN)</li><li><code>dims=ndims(data)</code>: Dimension along which to compute</li><li><code>n_lags=size(data,dims)</code>: Number of lags to compute</li></ul><p><strong>Returns</strong></p><ul><li>Array of autocorrelation values</li></ul><p><strong>Notes</strong></p><ul><li>Handles missing data using missing=&quot;conservative&quot; approach of </li></ul><p>statsmodels.tsa.stattools.acf. See https://www.statsmodels.org/dev/generated/statsmodels.tsa.stattools.acf.html  for details. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L394-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_cc-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Integer}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_cc-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Integer}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_cc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_cc(data1::AbstractArray{T}, data2::AbstractArray{T}, max_lag::Integer;
       dims::Int=ndims(data1)) where {T &lt;: Real}</code></pre><p>Compute cross-correlation between two arrays along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>data1</code>: First array of time series data</li><li><code>data2</code>: Second array of time series data</li><li><code>max_lag</code>: Maximum lag to compute</li><li><code>dims</code>: Dimension along which to compute cross-correlation (defaults to last dimension)</li></ul><p><strong>Returns</strong></p><p>Array with cross-correlation values, reduced along specified dimension</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L337-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_psd-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}} where T&lt;:Real" href="#IntrinsicTimescales.SummaryStats.comp_psd-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_psd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_psd(x::AbstractArray{T}, fs::Real; kwargs...) where {T &lt;: Real}</code></pre><p>Compute power spectral density using periodogram or welch method.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Time series data (time × channels)</li><li><code>fs</code>: Sampling frequency</li><li><code>dims=ndims(x)</code>: Dimension along which to compute PSD</li><li><code>method=&quot;periodogram&quot;</code>: Method to use (&quot;periodogram&quot; or &quot;welch&quot;)</li><li><code>window=dsp.hamming</code>: Window function</li><li><code>n=div(size(x,dims),8)</code>: Window size for Welch method</li><li><code>noverlap=div(n,2)</code>: Overlap for Welch method</li></ul><p><strong>Returns</strong></p><ul><li><code>power</code>: Power spectral density values</li><li><code>freqs</code>: Corresponding frequencies</li></ul><p><strong>Notes</strong></p><ul><li>For Welch method, carefully consider window size and overlap</li><li>Uses DSP.jl for underlying computations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L82-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}" href="#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>IntrinsicTimescales.SummaryStats.comp_psd_adfriendly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_psd_adfriendly(x::AbstractArray{&lt;:Real}, fs::Real; dims::Int=ndims(x))</code></pre><p>Compute power spectral density using an automatic differentiation (AD) friendly implementation.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Time series data</li><li><code>fs</code>: Sampling frequency</li><li><code>dims=ndims(x)</code>: Dimension along which to compute PSD</li></ul><p><strong>Returns</strong></p><ul><li><code>power</code>: Power spectral density values</li><li><code>freqs</code>: Corresponding frequencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L153-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}" href="#IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}"><code>IntrinsicTimescales.SummaryStats.comp_psd_lombscargle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">comp_psd_lombscargle(times, data, nanmask, dt; dims=ndims(data))</code></pre><p>Compute Lomb-Scargle periodogram for data with missing values.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>: Time points vector</li><li><code>data</code>: Time series data (may contain NaN)</li><li><code>nanmask</code>: Boolean mask indicating NaN positions</li><li><code>dt</code>: Time step</li><li><code>dims=ndims(data)</code>: Dimension along which to compute</li></ul><p><strong>Returns</strong></p><ul><li><code>power</code>: Lomb-Scargle periodogram values</li><li><code>frequency_grid</code>: Corresponding frequencies</li></ul><p><strong>Notes</strong></p><ul><li>Handles irregular sampling due to missing data</li><li>Uses frequency grid based on shortest valid time series</li><li>Automatically determines appropriate frequency range</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L273-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.SummaryStats.prepare_lombscargle-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{S}, AbstractMatrix{Bool}, Real}} where {T&lt;:Number, S&lt;:Number}" href="#IntrinsicTimescales.SummaryStats.prepare_lombscargle-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{S}, AbstractMatrix{Bool}, Real}} where {T&lt;:Number, S&lt;:Number}"><code>IntrinsicTimescales.SummaryStats.prepare_lombscargle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_lombscargle(times, data, nanmask)</code></pre><p>Prepare data for Lomb-Scargle periodogram computation by handling missing values.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>: Time points vector</li><li><code>data</code>: Time series data (may contain NaN)</li><li><code>nanmask</code>: Boolean mask indicating NaN positions</li></ul><p><strong>Returns</strong></p><ul><li><code>valid_times</code>: Time points with NaN values removed</li><li><code>valid_data</code>: Data points with NaN values removed</li><li><code>frequency_grid</code>: Suggested frequency grid for analysis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/summary.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Distances" href="#IntrinsicTimescales.Distances"><code>IntrinsicTimescales.Distances</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Distances</code></pre><p>Module providing distance metrics for comparing summary statistics in ABC inference. Currently implements linear (L2) and logarithmic distances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/distances.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Distances.linear_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}" href="#IntrinsicTimescales.Distances.linear_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}"><code>IntrinsicTimescales.Distances.linear_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">linear_distance(data, synth_data)</code></pre><p>Compute mean squared (L2) distance between summary statistics.</p><p><strong>Arguments</strong></p><ul><li><code>data::Union{AbstractArray, Real}</code>: Observed data summary statistics</li><li><code>synth_data::Union{AbstractArray, Real}</code>: Simulated data summary statistics</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Mean squared difference between data and synth_data</li></ul><p><strong>Notes</strong></p><ul><li>Handles both scalar and array inputs</li><li>For arrays, computes element-wise differences before averaging</li><li>Useful for comparing summary statistics on linear scales</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/distances.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Distances.logarithmic_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}" href="#IntrinsicTimescales.Distances.logarithmic_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}"><code>IntrinsicTimescales.Distances.logarithmic_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logarithmic_distance(data, synth_data)</code></pre><p>Compute mean squared distance between logarithms of summary statistics.</p><p><strong>Arguments</strong></p><ul><li><code>data::Union{AbstractArray, Real}</code>: Observed data summary statistics</li><li><code>synth_data::Union{AbstractArray, Real}</code>: Simulated data summary statistics</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Mean squared difference between log(data) and log(synth_data)</li></ul><p><strong>Notes</strong></p><ul><li>Handles both scalar and array inputs</li><li>For arrays, computes element-wise log differences before averaging</li><li>Useful for comparing summary statistics spanning multiple orders of magnitude</li><li>Assumes all values are positive</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/stats/distances.jl#L33-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils" href="#IntrinsicTimescales.Utils"><code>IntrinsicTimescales.Utils</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Utils</code></pre><p>Module providing utility functions for time series analysis, including:</p><ul><li>Exponential decay fitting</li><li>Oscillation peak detection</li><li>Knee frequency estimation</li><li>Lorentzian fitting</li><li>ACF width calculations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.acw0-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}" href="#IntrinsicTimescales.Utils.acw0-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}"><code>IntrinsicTimescales.Utils.acw0</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acw0(lags, acf; dims=ndims(acf))</code></pre><p>Compute the ACW0 (autocorrelation width at zero crossing) along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>lags::AbstractVector{T}</code>: Vector of lag values</li><li><code>acf::AbstractArray{T}</code>: Array of autocorrelation values</li><li><code>dims::Int=ndims(acf)</code>: Dimension along which to compute ACW0</li></ul><p><strong>Returns</strong></p><ul><li>First lag where autocorrelation crosses zero</li></ul><p><strong>Notes</strong></p><ul><li>Alternative measure of characteristic timescale</li><li>More sensitive to noise than ACW50</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L124-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.acw50-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#IntrinsicTimescales.Utils.acw50-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.acw50</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acw50(lags, acf; dims=ndims(acf))</code></pre><p>Compute the ACW50 (autocorrelation width at 50%) along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>lags::AbstractVector{T}</code>: Vector of lag values</li><li><code>acf::AbstractArray{T}</code>: Array of autocorrelation values</li><li><code>dims::Int=ndims(acf)</code>: Dimension along which to compute ACW50</li></ul><p><strong>Returns</strong></p><ul><li>First lag where autocorrelation falls below 0.5</li></ul><p><strong>Notes</strong></p><ul><li>Used for estimating characteristic timescales</li><li>Related to tau by: tau = -acw50/log(0.5)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L96-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.acw_romberg-Union{Tuple{S}, Tuple{Real, AbstractVector{S}}} where S&lt;:Real" href="#IntrinsicTimescales.Utils.acw_romberg-Union{Tuple{S}, Tuple{Real, AbstractVector{S}}} where S&lt;:Real"><code>IntrinsicTimescales.Utils.acw_romberg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acw_romberg(lags, acf)</code></pre><p>Calculate the area under the curve of ACF using Romberg integration.</p><p><strong>Arguments</strong></p><ul><li><code>dt::Real</code>: Time step</li><li><code>acf::AbstractVector</code>: Array of autocorrelation values</li></ul><p><strong>Returns</strong></p><ul><li>AUC of ACF</li></ul><p><strong>Notes</strong></p><ul><li>Returns only the integral value, discarding the error estimate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L183-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.acweuler-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}" href="#IntrinsicTimescales.Utils.acweuler-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}"><code>IntrinsicTimescales.Utils.acweuler</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">acweuler(lags, acf; dims=ndims(acf))</code></pre><p>Compute the ACW at 1/e (≈ 0.368) along specified dimension.</p><p><strong>Arguments</strong></p><ul><li><code>lags::AbstractVector{T}</code>: Vector of lag values</li><li><code>acf::AbstractArray{S}</code>: Array of autocorrelation values</li><li><code>dims::Int=ndims(acf)</code>: Dimension along which to compute</li></ul><p><strong>Returns</strong></p><ul><li>First lag where autocorrelation falls below 1/e</li></ul><p><strong>Notes</strong></p><ul><li>For exponential decay, equals the timescale parameter tau</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L156-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.expdecay-Tuple{Any, Any}" href="#IntrinsicTimescales.Utils.expdecay-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.expdecay</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">expdecay(tau, lags)</code></pre><p>Compute exponential decay function.</p><p><strong>Arguments</strong></p><ul><li><code>tau::Real</code>: Timescale parameter</li><li><code>lags::AbstractVector</code>: Time lags</li></ul><p><strong>Returns</strong></p><ul><li>Vector of exp(-t/tau) values</li></ul><p><strong>Notes</strong></p><ul><li>Used for fitting autocorrelation functions</li><li>Assumes exponential decay model: acf = exp(-t/tau)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.find_knee_frequency-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#IntrinsicTimescales.Utils.find_knee_frequency-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.find_knee_frequency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_knee_frequency(psd, freqs; dims=ndims(psd), min_freq=freqs[1], max_freq=freqs[end])</code></pre><p>Find knee frequency by fitting Lorentzian to power spectral density.</p><p><strong>Arguments</strong></p><ul><li><code>psd::AbstractArray{T}</code>: Power spectral density values</li><li><code>freqs::Vector{T}</code>: Frequency values</li><li><code>dims::Int=ndims(psd)</code>: Dimension along which to compute</li><li><code>min_freq::T=freqs[1]</code>: Minimum frequency to consider</li><li><code>max_freq::T=freqs[end]</code>: Maximum frequency to consider</li><li><code>constrained::Bool=false</code>: Whether to use constrained optimization</li><li><code>allow_variable_exponent::Bool=false</code>: Whether to allow variable exponent (PLE)</li></ul><p><strong>Returns</strong></p><ul><li>Vector of the fit  for the equation amp/(1 + (f/knee)^{exponent}). </li></ul><p>If allow<em>variable</em>exponent=false, assumes exponent=2 and returns [amplitude, knee<em>frequency]. If true,  returns [amplitude, knee</em>frequency, exponent].</p><p><strong>Notes</strong></p><ul><li>Uses Lorentzian fitting with NonlinearSolve.jl</li><li>Initial guess for amplitude is based average value of low frequency power. For knee, this is half-power point. For exponent, it is 2.0.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L307-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.find_oscillation_peak-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#IntrinsicTimescales.Utils.find_oscillation_peak-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Utils.find_oscillation_peak</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_oscillation_peak(psd, freqs; min_freq=5.0/1000.0, max_freq=50.0/1000.0, min_prominence_ratio=0.1)</code></pre><p>Find dominant oscillatory peak in power spectral density.</p><p><strong>Arguments</strong></p><ul><li><code>psd::AbstractVector</code>: Power spectral density values</li><li><code>freqs::AbstractVector</code>: Frequency values</li><li><code>min_freq::Real=5.0/1000.0</code>: Minimum frequency to consider</li><li><code>max_freq::Real=50.0/1000.0</code>: Maximum frequency to consider</li><li><code>min_prominence_ratio::Real=0.1</code>: Minimum peak prominence as fraction of max PSD</li></ul><p><strong>Returns</strong></p><ul><li>Frequency of most prominent peak, or NaN if no significant peak found</li></ul><p><strong>Notes</strong></p><ul><li>Uses peak prominence for robustness</li><li>Filters peaks by minimum prominence threshold</li><li>Returns NaN if no peaks meet criteria</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L513-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.fit_expdecay-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#IntrinsicTimescales.Utils.fit_expdecay-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.fit_expdecay</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_expdecay(lags, acf; dims=ndims(acf))</code></pre><p>Fit exponential decay to autocorrelation function.</p><p><strong>Arguments</strong></p><ul><li><code>lags::AbstractVector{T}</code>: Time lags</li><li><code>acf::AbstractArray{T}</code>: Autocorrelation values</li><li><code>dims::Int=ndims(acf)</code>: Dimension along which to fit</li></ul><p><strong>Returns</strong></p><ul><li>Fitted timescale parameter(s)</li></ul><p><strong>Notes</strong></p><ul><li>Uses NonlinearSolve.jl with FastShortcutNLLSPolyalg</li><li>Initial guess based on ACW50</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L59-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.fit_gaussian-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}" href="#IntrinsicTimescales.Utils.fit_gaussian-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><code>IntrinsicTimescales.Utils.fit_gaussian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_gaussian(psd, freqs, initial_peak; min_freq=freqs[1], max_freq=freqs[end])</code></pre><p>Fit Gaussian to power spectral density around a peak.</p><p><strong>Arguments</strong></p><ul><li><code>psd::AbstractVector{&lt;:Real}</code>: Power spectral density values</li><li><code>freqs::AbstractVector{&lt;:Real}</code>: Frequency values</li><li><code>initial_peak::Real</code>: Initial guess for center frequency</li><li><code>min_freq::Real</code>: Minimum frequency to consider</li><li><code>max_freq::Real</code>: Maximum frequency to consider</li></ul><p><strong>Returns</strong></p><ul><li>Vector{Float64}: Fitted parameters [amplitude, center<em>freq, std</em>dev]</li></ul><p><strong>Notes</strong></p><ul><li>Uses initial peak location from find<em>oscillation</em>peak</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L605-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.fooof_fit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real" href="#IntrinsicTimescales.Utils.fooof_fit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.fooof_fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fooof_fit(psd, freqs; dims=ndims(psd), min_freq=freqs[1], max_freq=freqs[end], 
          oscillation_peak=true, max_peaks=3, allow_variable_exponent=false, constrained=false)</code></pre><p>Perform FOOOF-style fitting of power spectral density. The default behavior is to fit a Lorentzian with PLE = 2.  If allow<em>variable</em>exponent=true, the function will fit a Lorentzian with variable PLE. </p><p><strong>Arguments</strong></p><ul><li><code>psd::AbstractArray{T}</code>: Power spectral density values</li><li><code>freqs::Vector{T}</code>: Frequency values</li><li><code>dims::Int=ndims(psd)</code>: Dimension along which to compute</li><li><code>min_freq::T=freqs[1]</code>: Minimum frequency to consider</li><li><code>max_freq::T=freqs[end]</code>: Maximum frequency to consider</li><li><code>oscillation_peak::Bool=true</code>: Whether to compute oscillation peaks</li><li><code>max_peaks::Int=3</code>: Maximum number of oscillatory peaks to fit</li><li><code>allow_variable_exponent::Bool=false</code>: Whether to allow variable exponent (PLE)</li><li><code>constrained::Bool=false</code>: Whether to use constrained optimization</li></ul><p><strong>Returns</strong></p><p>If return<em>only</em>knee=false:</p><ul><li>Tuple of (knee<em>frequency, oscillation</em>parameters) where oscillation<em>parameters is Vector of (center</em>freq, amplitude, std_dev) for each peak</li></ul><p>If return<em>only</em>knee=true:</p><ul><li>knee_frequency only</li></ul><p><strong>Notes</strong></p><ul><li>Implements iterative FOOOF-style fitting:<ol><li>Fit initial Lorentzian to PSD</li><li>Find and fit Gaussian peaks iteratively</li><li>Subtract all Gaussians from original PSD</li><li>Refit Lorentzian to cleaned PSD</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L389-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.gaussian-Tuple{Any, Any}" href="#IntrinsicTimescales.Utils.gaussian-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.gaussian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian(f, u)</code></pre><p>Gaussian function for fitting oscillations. </p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractVector</code>: Frequency values</li><li><code>u::Vector</code>: Parameters [amplitude, center<em>freq, std</em>dev]</li></ul><p><strong>Returns</strong></p><ul><li>Vector of Gaussian values: amp * exp(-(f-center)²/(2*std²))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L583-L594">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.lorentzian-Tuple{Any, Any}" href="#IntrinsicTimescales.Utils.lorentzian-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.lorentzian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lorentzian(f, u)</code></pre><p>Compute Lorentzian function values.</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractVector</code>: Frequency values</li><li><code>u::Vector</code>: Parameters [amplitude, knee_frequency]</li></ul><p><strong>Returns</strong></p><ul><li>Vector of Lorentzian values: amp/(1 + (f/knee)²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L208-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.lorentzian_initial_guess-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#IntrinsicTimescales.Utils.lorentzian_initial_guess-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Utils.lorentzian_initial_guess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lorentzian_initial_guess(psd, freqs; min_freq=freqs[1], max_freq=freqs[end])</code></pre><p>Estimate initial parameters for Lorentzian fitting.</p><p><strong>Arguments</strong></p><ul><li><code>psd::AbstractVector{&lt;:Real}</code>: Power spectral density values</li><li><code>freqs::AbstractVector{&lt;:Real}</code>: Frequency values</li><li><code>min_freq::Real</code>: Minimum frequency to consider</li><li><code>max_freq::Real</code>: Maximum frequency to consider</li></ul><p><strong>Returns</strong></p><ul><li>Vector{Float64}: Initial guess for [amplitude, knee_frequency]</li></ul><p><strong>Notes</strong></p><ul><li>Estimates amplitude from average power of low frequencies. </li><li>Estimates knee frequency from half-power point. </li><li>If allow<em>variable</em>exponent=true, sets initial guess for exponent to 2.0. </li><li>Used as starting point for nonlinear fitting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L260-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.lorentzian_with_exponent-Tuple{Any, Any}" href="#IntrinsicTimescales.Utils.lorentzian_with_exponent-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.lorentzian_with_exponent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lorentzian_with_exponent(f, u)</code></pre><p>Compute Lorentzian function values that allow variable exponent (PLE).</p><p><strong>Arguments</strong></p><ul><li><code>f::AbstractVector</code>: Frequency values</li><li><code>u::Vector</code>: Parameters [amplitude, knee_frequency, exponent]</li></ul><p><strong>Returns</strong></p><ul><li>Vector of Lorentzian values: amp/(1 + (f/knee)²)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Utils.residual_expdecay!-Tuple{Any, Any, Any}" href="#IntrinsicTimescales.Utils.residual_expdecay!-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.Utils.residual_expdecay!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Residual function for expdecay du: residual u: parameters p: data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/utils.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OrnsteinUhlenbeck" href="#IntrinsicTimescales.OrnsteinUhlenbeck"><code>IntrinsicTimescales.OrnsteinUhlenbeck</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OrnsteinUhlenbeck</code></pre><p>Module for generating Ornstein-Uhlenbeck processes with various configurations. Uses DifferentialEquations.jl. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/ou_process.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process-Tuple{Union{Real, Vector{&lt;:Real}}, Vararg{Real, 4}}" href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process-Tuple{Union{Real, Vector{&lt;:Real}}, Vararg{Real, 4}}"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_ou_process(tau, true_D, dt, duration, num_trials; standardize=true)</code></pre><p>Generate an Ornstein-Uhlenbeck process with a single timescale</p><p><strong>Arguments</strong></p><ul><li><code>tau::Union{Real, Vector{&lt;:Real}}</code>: Timescale(s) of the OU process</li><li><code>true_D::Real</code>: Target variance for scaling the process</li><li><code>dt::Real</code>: Time step size</li><li><code>duration::Real</code>: Total time length</li><li><code>num_trials::Real</code>: Number of trials/trajectories</li><li><code>standardize::Bool=true</code>: Whether to standardize output to match true_D</li></ul><p><strong>Returns</strong></p><ul><li>Matrix{Float64}: Generated OU process data with dimensions (num<em>trials, num</em>timesteps)</li></ul><p><strong>Notes</strong></p><ul><li>Uses generate<em>ou</em>process_sciml internally</li><li>Returns NaN matrix if SciML solver fails</li><li>Standardizes output to have specified variance if standardize=true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/ou_process.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process_sciml-Union{Tuple{T}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer, Bool}} where T&lt;:Real" href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process_sciml-Union{Tuple{T}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer, Bool}} where T&lt;:Real"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process_sciml</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_ou_process_sciml(tau, true_D, dt, duration, num_trials, standardize=true)</code></pre><p>Generate an Ornstein-Uhlenbeck process using DifferentialEquations.jl.</p><p><strong>Arguments</strong></p><ul><li><code>tau::Union{T, Vector{T}}</code>: Timescale(s) of the OU process</li><li><code>true_D::Real</code>: Target variance for scaling</li><li><code>dt::Real</code>: Time step size</li><li><code>duration::Real</code>: Total time length</li><li><code>num_trials::Integer</code>: Number of trials/trajectories</li><li><code>standardize::Bool=true</code>: Whether to standardize output</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Matrix{Float64}, ODESolution}</code>: <ul><li>Scaled OU process data</li><li>Full SDE solution object</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Uses SOSRA solver for efficiency</li><li>Switches between static and dynamic arrays based on num_trials</li><li>Standardizes output to match true_D if standardize=true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/ou_process.jl#L70-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_with_oscillation-Union{Tuple{T}, Tuple{Vector{T}, Real, Real, Integer, Real, Real}} where T&lt;:Real" href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_with_oscillation-Union{Tuple{T}, Tuple{Vector{T}, Real, Real, Integer, Real, Real}} where T&lt;:Real"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_with_oscillation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_ou_with_oscillation(theta, dt, duration, num_trials, data_mean, data_var)</code></pre><p>Generate a one-timescale OU process with an additive oscillation.</p><p><strong>Arguments</strong></p><ul><li><code>theta::Vector{T}</code>: Parameters [timescale, frequency, coefficient]</li><li><code>dt::Real</code>: Time step size</li><li><code>duration::Real</code>: Total time length</li><li><code>num_trials::Integer</code>: Number of trials</li><li><code>data_mean::Real</code>: Target mean value</li><li><code>data_var::Real</code>: Target variance</li></ul><p><strong>Returns</strong></p><ul><li>Matrix{Float64}: Generated data with dimensions (num<em>trials, num</em>timesteps)</li></ul><p><strong>Notes</strong></p><ul><li>Coefficient is bounded between 0 and 1</li><li>Combines OU process with sinusoidal oscillation</li><li>Standardizes and scales output to match target mean and variance</li><li>Returns NaN matrix if SciML solver fails</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/utils/ou_process.jl#L122-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescale" href="#IntrinsicTimescales.OneTimescale"><code>IntrinsicTimescales.OneTimescale</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescale</code></pre><p>Module for inferring a single timescale from time series data using the Ornstein-Uhlenbeck process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescale.OneTimescaleModel" href="#IntrinsicTimescales.OneTimescale.OneTimescaleModel"><code>IntrinsicTimescales.OneTimescale.OneTimescaleModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleModel &lt;: AbstractTimescaleModel</code></pre><p>Model for inferring a single timescale from time series data using the Ornstein-Uhlenbeck process. We recommend using the <code>one_timescale_model</code> constructor function rather than creating directly.</p><p><strong>Fields</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data</li><li><code>time::AbstractVector{&lt;:Real}</code>: Time points corresponding to the data</li><li><code>fit_method::Symbol</code>: Fitting method (:abc or :advi)</li><li><code>summary_method::Symbol</code>: Summary statistic type (:psd or :acf)</li><li><code>lags_freqs</code>: Lags (for ACF) or frequencies (for PSD)</li><li><code>prior</code>: Prior distribution(s) for parameters</li><li><code>distance_method::Symbol</code>: Distance metric type (:linear or :logarithmic)</li><li><code>data_sum_stats</code>: Pre-computed summary statistics</li><li><code>dt::Real</code>: Time step between observations</li><li><code>T::Real</code>: Total time span</li><li><code>numTrials::Real</code>: Number of trials/iterations</li><li><code>data_mean::Real</code>: Mean of input data</li><li><code>data_sd::Real</code>: Standard deviation of input data</li><li><code>freqlims</code>: Frequency limits for PSD analysis</li><li><code>n_lags</code>: Number of lags for ACF</li><li><code>freq_idx</code>: Boolean mask for frequency selection</li><li><code>dims::Int</code>: Dimension along which to compute statistics</li><li><code>distance_combined::Bool</code>: Whether to use combined distance metric</li><li><code>weights::Vector{Real}</code>: Weights for combined distance</li><li><code>data_tau::Union{Real, Nothing}</code>: Pre-computed timescale</li><li><code>u0::Union{Vector{Real}, Nothing}</code>: Initial parameter guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L32-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleModel, Any, Any}" href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.distance_function(model::OneTimescaleModel, sum_stats, data_sum_stats)</code></pre><p>Calculate the distance between summary statistics of simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleModel</code>: Model instance</li><li><code>sum_stats</code>: Summary statistics from simulated data</li><li><code>data_sum_stats</code>: Summary statistics from observed data</li></ul><p><strong>Returns</strong></p><ul><li>Distance value based on model.distance<em>method (:linear or :logarithmic) or combined distance if model.distance</em>combined is true</li></ul><p><strong>Notes</strong></p><p>If distance_combined is true:</p><ul><li>For ACF: Combines ACF distance with fitted exponential decay timescale distance</li><li>For PSD: Combines PSD distance with knee frequency timescale distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L280-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleModel, Any}" href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.generate_data(model::OneTimescaleModel, theta)</code></pre><p>Generate synthetic data from the Ornstein-Uhlenbeck process with given timescale.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleModel</code>: Model instance containing simulation parameters</li><li><code>theta</code>: Vector containing single timescale parameter (τ)</li></ul><p><strong>Returns</strong></p><ul><li>Synthetic time series data with same dimensions as model.data</li></ul><p><strong>Notes</strong></p><p>Uses the model&#39;s stored parameters:</p><ul><li><code>data_sd</code>: Standard deviation for the OU process</li><li><code>dt</code>: Time step</li><li><code>T</code>: Total time span</li><li><code>numTrials</code>: Number of trials/trajectories</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L195-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.int_fit" href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">int_fit(model::OneTimescaleModel, param_dict=nothing)</code></pre><p>Perform inference using the specified fitting method.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleModel</code>: Model instance</li><li><code>param_dict=nothing</code>: Optional dictionary of algorithm parameters. If nothing, uses defaults.</li></ul><p><strong>Returns</strong></p><p>For ABC method:</p><ul><li><code>posterior_samples</code>: Matrix of accepted parameter samples</li><li><code>posterior_MAP</code>: Maximum a posteriori estimate</li><li><code>abc_record</code>: Full record of ABC iterations</li></ul><p>For ADVI method:</p><ul><li><code>ADVIResults</code>: Container with samples, MAP estimates, variances, and full chain</li></ul><p><strong>Notes</strong></p><ul><li>For ABC: Uses Population Monte Carlo ABC with adaptive epsilon selection</li><li>For ADVI: Uses Automatic Differentiation Variational Inference via Turing.jl</li><li>Parameter dictionary can be customized for each method (see get<em>param</em>dict_abc())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L317-L339">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleModel, Any}" href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.summary_stats(model::OneTimescaleModel, data)</code></pre><p>Compute summary statistics (ACF or PSD) from time series data.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleModel</code>: Model instance specifying summary statistic type</li><li><code>data</code>: Time series data to analyze</li></ul><p><strong>Returns</strong></p><p>For ACF (<code>summary_method = :acf</code>):</p><ul><li>Mean autocorrelation function up to <code>n_lags</code></li></ul><p>For PSD (<code>summary_method = :psd</code>):</p><ul><li>Mean power spectral density within specified frequency range</li></ul><p><strong>Notes</strong></p><ul><li>ACF is computed using FFT-based method</li><li>PSD is computed and filtered according to model.freq_idx</li><li>Throws ArgumentError if summary_method is invalid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L218-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescale.combined_distance-Tuple{OneTimescaleModel, Vararg{Any, 5}}" href="#IntrinsicTimescales.OneTimescale.combined_distance-Tuple{OneTimescaleModel, Vararg{Any, 5}}"><code>IntrinsicTimescales.OneTimescale.combined_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combined_distance(model::OneTimescaleModel, simulation_summary, data_summary,
                 weights, data_tau, simulation_tau)</code></pre><p>Compute combined distance metric between simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: OneTimescaleModel instance</li><li><code>simulation_summary</code>: Summary statistics from simulation</li><li><code>data_summary</code>: Summary statistics from observed data</li><li><code>weights</code>: Weights for combining distances</li><li><code>data_tau</code>: Timescale from observed data</li><li><code>simulation_tau</code>: Timescale from simulation</li></ul><p><strong>Returns</strong></p><ul><li>Weighted combination of summary statistic distance and timescale distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L249-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescale.one_timescale_model-Tuple{Any, Any, Any}" href="#IntrinsicTimescales.OneTimescale.one_timescale_model-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.OneTimescale.one_timescale_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">one_timescale_model(data, time, fit_method; kwargs...)</code></pre><p>Construct a OneTimescaleModel for time series analysis.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input time series data</li><li><code>time</code>: Time points corresponding to the data</li><li><code>fit_method</code>: Fitting method to use (:abc or :advi)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>summary_method=:acf</code>: Summary statistic type (:psd or :acf)</li><li><code>data_sum_stats=nothing</code>: Pre-computed summary statistics</li><li><code>lags_freqs=nothing</code>: Custom lags or frequencies</li><li><code>prior=nothing</code>: Prior distribution(s) for parameters</li><li><code>n_lags=nothing</code>: Number of lags for ACF</li><li><code>distance_method=nothing</code>: Distance metric type</li><li><code>dt=time[2]-time[1]</code>: Time step</li><li><code>T=time[end]</code>: Total time span</li><li><code>numTrials=size(data,1)</code>: Number of trials</li><li><code>data_mean=mean(data)</code>: Data mean</li><li><code>data_sd=std(data)</code>: Data standard deviation</li><li><code>freqlims=nothing</code>: Frequency limits for PSD</li><li><code>freq_idx=nothing</code>: Frequency selection mask</li><li><code>dims=ndims(data)</code>: Analysis dimension</li><li><code>distance_combined=false</code>: Use combined distance</li><li><code>weights=[0.5, 0.5]</code>: Distance weights</li><li><code>data_tau=nothing</code>: Pre-computed timescale</li><li><code>u0=nothing</code>: Initial parameter guess</li></ul><p><strong>Returns</strong></p><ul><li><code>OneTimescaleModel</code>: Model instance configured for specified analysis method</li></ul><p><strong>Notes</strong></p><p>Two main usage patterns:</p><ol><li>ACF-based inference: <code>summary_method=:acf</code>, <code>fit_method=:abc/:advi</code></li><li>PSD-based inference: <code>summary_method=:psd</code>, <code>fit_method=:abc/:advi</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale.jl#L85-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleAndOsc.OneTimescaleAndOscModel" href="#IntrinsicTimescales.OneTimescaleAndOsc.OneTimescaleAndOscModel"><code>IntrinsicTimescales.OneTimescaleAndOsc.OneTimescaleAndOscModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleAndOscModel &lt;: AbstractTimescaleModel</code></pre><p>Model for inferring a single timescale and oscillation from time series data using the Ornstein-Uhlenbeck process. Parameters: [tau, freq, coeff] representing timescale, oscillation frequency, and oscillation coefficient.</p><p><strong>Fields</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data</li><li><code>time::AbstractVector{&lt;:Real}</code>: Time points corresponding to the data</li><li><code>fit_method::Symbol</code>: Fitting method (:abc or :advi)</li><li><code>summary_method::Symbol</code>: Summary statistic type (:psd or :acf)</li><li><code>lags_freqs</code>: Lags (for ACF) or frequencies (for PSD)</li><li><code>prior</code>: Prior distribution(s) for parameters</li><li><code>distance_method::Symbol</code>: Distance metric type (:linear or :logarithmic)</li><li><code>data_sum_stats</code>: Pre-computed summary statistics</li><li><code>dt::Real</code>: Time step between observations</li><li><code>T::Real</code>: Total time span</li><li><code>numTrials::Real</code>: Number of trials/iterations</li><li><code>data_mean::Real</code>: Mean of input data</li><li><code>data_sd::Real</code>: Standard deviation of input data</li><li><code>freqlims</code>: Frequency limits for PSD analysis</li><li><code>n_lags</code>: Number of lags for ACF</li><li><code>freq_idx</code>: Boolean mask for frequency selection</li><li><code>dims::Int</code>: Dimension along which to compute statistics</li><li><code>distance_combined::Bool</code>: Whether to use combined distance metric</li><li><code>weights::Vector{Real}</code>: Weights for combined distance</li><li><code>data_tau::Union{Real, Nothing}</code>: Pre-computed timescale</li><li><code>data_osc::Union{Real, Nothing}</code>: Pre-computed oscillation frequency</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L45-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleAndOscModel, Any, Any}" href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleAndOscModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.distance_function(model::OneTimescaleAndOscModel, sum_stats, data_sum_stats)</code></pre><p>Calculate the distance between summary statistics of simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscModel</code>: Model instance</li><li><code>sum_stats</code>: Summary statistics from simulated data</li><li><code>data_sum_stats</code>: Summary statistics from observed data</li></ul><p><strong>Returns</strong></p><ul><li>Distance value based on model.distance<em>method (:linear or :logarithmic) or combined distance if model.distance</em>combined is true</li></ul><p><strong>Notes</strong></p><p>If distance_combined is true:</p><ul><li>For ACF: Combines ACF distance with fitted exponential decay timescale distance</li><li>For PSD: Combines PSD distance with knee frequency timescale distance and oscillation frequency distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L335-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscModel, AbstractVector{&lt;:Real}}" href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscModel, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Models.generate_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.generate_data(model::OneTimescaleAndOscModel, theta::AbstractVector{&lt;:Real})</code></pre><p>Generate synthetic data from the Ornstein-Uhlenbeck process with oscillation.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscModel</code>: Model instance containing simulation parameters</li><li><code>theta::AbstractVector{&lt;:Real}</code>: Vector containing parameters [tau, freq, coeff]</li></ul><p><strong>Returns</strong></p><ul><li>Synthetic time series data with same dimensions as model.data</li></ul><p><strong>Notes</strong></p><p>Uses the model&#39;s stored parameters:</p><ul><li><code>dt</code>: Time step</li><li><code>T</code>: Total time span</li><li><code>numTrials</code>: Number of trials/trajectories</li><li><code>data_mean</code>: Mean of the process</li><li><code>data_sd</code>: Standard deviation of the process</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L229-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.int_fit" href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">int_fit(model::OneTimescaleAndOscModel, param_dict=nothing)</code></pre><p>Perform inference using the specified fitting method.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscModel</code>: Model instance</li><li><code>param_dict=nothing</code>: Optional dictionary of algorithm parameters. If nothing, uses defaults.</li></ul><p><strong>Returns</strong></p><p>For ABC method:</p><ul><li><code>posterior_samples</code>: Matrix of accepted parameter samples</li><li><code>posterior_MAP</code>: Maximum a posteriori estimate</li><li><code>abc_record</code>: Full record of ABC iterations</li></ul><p>For ADVI method:</p><ul><li>`ADVIResults: Container with samples, MAP estimates, variances, and full variational posterior</li></ul><p><strong>Notes</strong></p><ul><li>For ABC: Uses Population Monte Carlo ABC with adaptive epsilon selection</li><li>For ADVI: Uses Automatic Differentiation Variational Inference via Turing.jl</li><li>Parameter dictionary can be customized for each method (see get<em>param</em>dict_abc())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L381-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscModel, Any}" href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.summary_stats(model::OneTimescaleAndOscModel, data)</code></pre><p>Compute summary statistics (ACF or PSD) from time series data.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscModel</code>: Model instance specifying summary statistic type</li><li><code>data</code>: Time series data to analyze</li></ul><p><strong>Returns</strong></p><p>For ACF (<code>summary_method = :acf</code>):</p><ul><li>Mean autocorrelation function up to <code>n_lags</code></li></ul><p>For PSD (<code>summary_method = :psd</code>):</p><ul><li>Mean power spectral density within specified frequency range</li></ul><p><strong>Notes</strong></p><ul><li>ACF is computed using FFT-based method</li><li>PSD is computed using AD-friendly implementation</li><li>Throws ArgumentError if summary_method is invalid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L254-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleAndOsc.combined_distance-Tuple{OneTimescaleAndOscModel, Vararg{Any, 8}}" href="#IntrinsicTimescales.OneTimescaleAndOsc.combined_distance-Tuple{OneTimescaleAndOscModel, Vararg{Any, 8}}"><code>IntrinsicTimescales.OneTimescaleAndOsc.combined_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combined_distance(model::OneTimescaleAndOscModel, simulation_summary, data_summary,
                 weights, distance_method, data_tau, simulation_tau, 
                 data_osc, simulation_osc)</code></pre><p>Compute combined distance metric between simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: OneTimescaleAndOscModel instance</li><li><code>simulation_summary</code>: Summary statistics from simulation</li><li><code>data_summary</code>: Summary statistics from observed data</li><li><code>weights</code>: Weights for combining distances</li><li><code>distance_method</code>: Distance metric type</li><li><code>data_tau</code>: Timescale from observed data</li><li><code>simulation_tau</code>: Timescale from simulation</li><li><code>data_osc</code>: Oscillation frequency from observed data</li><li><code>simulation_osc</code>: Oscillation frequency from simulation</li></ul><p><strong>Returns</strong></p><p>For ACF:</p><ul><li>Weighted combination of summary statistic distance and timescale distance</li></ul><p>For PSD:</p><ul><li>Weighted combination of summary statistic distance, timescale distance, and oscillation frequency distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc.jl#L285-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleWithMissing" href="#IntrinsicTimescales.OneTimescaleWithMissing"><code>IntrinsicTimescales.OneTimescaleWithMissing</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleWithMissing</code></pre><p>Module for handling time series analysis with missing data. Uses specialized methods for handling NaN values:</p><ul><li>For ACF: Uses comp<em>ac</em>time_missing (equivalent to statsmodels.tsa.statstools.acf with missing=&quot;conservative&quot;)</li><li>For PSD: Uses Lomb-Scargle periodogram to handle irregular sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleWithMissing.OneTimescaleWithMissingModel" href="#IntrinsicTimescales.OneTimescaleWithMissing.OneTimescaleWithMissingModel"><code>IntrinsicTimescales.OneTimescaleWithMissing.OneTimescaleWithMissingModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleWithMissingModel &lt;: AbstractTimescaleModel</code></pre><p>Model for inferring a single timescale from time series data with missing values.</p><p><strong>Fields</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data (may contain NaN)</li><li><code>time::AbstractVector{&lt;:Real}</code>: Time points corresponding to the data</li><li><code>fit_method::Symbol</code>: Fitting method (:abc or :advi)</li><li><code>summary_method::Symbol</code>: Summary statistic type (:psd or :acf)</li><li><code>lags_freqs</code>: Lags (for ACF) or frequencies (for PSD)</li><li><code>prior</code>: Prior distribution(s) for parameters</li><li><code>distance_method::Symbol</code>: Distance metric type (:linear or :logarithmic)</li><li><code>data_sum_stats</code>: Pre-computed summary statistics</li><li><code>dt::Real</code>: Time step between observations</li><li><code>T::Real</code>: Total time span</li><li><code>numTrials::Real</code>: Number of trials/iterations</li><li><code>data_mean::Real</code>: Mean of input data (excluding NaN)</li><li><code>data_sd::Real</code>: Standard deviation of input data (excluding NaN)</li><li><code>freqlims</code>: Frequency limits for PSD analysis</li><li><code>n_lags</code>: Number of lags for ACF</li><li><code>freq_idx</code>: Boolean mask for frequency selection</li><li><code>dims::Int</code>: Dimension along which to compute statistics</li><li><code>distance_combined::Bool</code>: Whether to use combined distance metric</li><li><code>weights::Vector{Real}</code>: Weights for combined distance</li><li><code>data_tau::Union{Real, Nothing}</code>: Pre-computed timescale</li><li><code>missing_mask::AbstractArray{Bool}</code>: Boolean mask indicating NaN positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L33-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleWithMissingModel, Any, Any}" href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleWithMissingModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.distance_function(model::OneTimescaleWithMissingModel, sum_stats, data_sum_stats)</code></pre><p>Calculate the distance between summary statistics of simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleWithMissingModel</code>: Model instance</li><li><code>sum_stats</code>: Summary statistics from simulated data</li><li><code>data_sum_stats</code>: Summary statistics from observed data</li></ul><p><strong>Returns</strong></p><ul><li>Distance value based on model.distance<em>method (:linear or :logarithmic) or combined distance if model.distance</em>combined is true</li></ul><p><strong>Notes</strong></p><p>If distance_combined is true:</p><ul><li>For ACF: Combines ACF distance with fitted exponential decay timescale distance</li><li>For PSD: Combines PSD distance with knee frequency timescale distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L279-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleWithMissingModel, Any}" href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleWithMissingModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.generate_data(model::OneTimescaleWithMissingModel, theta)</code></pre><p>Generate synthetic data from the Ornstein-Uhlenbeck process and apply missing data mask.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleWithMissingModel</code>: Model instance containing simulation parameters</li><li><code>theta</code>: Vector containing single timescale parameter (τ)</li></ul><p><strong>Returns</strong></p><ul><li>Synthetic time series data with NaN values at positions specified by model.missing_mask</li></ul><p><strong>Notes</strong></p><ol><li>Generates complete OU process data</li><li>Applies missing data mask from original data</li><li>Returns data with same missing value pattern as input</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L212-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.int_fit" href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">int_fit(model::OneTimescaleWithMissingModel, param_dict=nothing)</code></pre><p>Perform inference using the specified fitting method.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleWithMissingModel</code>: Model instance</li><li><code>param_dict=nothing</code>: Optional dictionary of algorithm parameters. If nothing, uses defaults.</li></ul><p><strong>Returns</strong></p><p>For ABC method:</p><ul><li><code>posterior_samples</code>: Matrix of accepted parameter samples</li><li><code>posterior_MAP</code>: Maximum a posteriori estimate</li><li><code>abc_record</code>: Full record of ABC iterations</li></ul><p>For ADVI method:</p><ul><li><code>ADVIResults</code>: Container with samples, MAP estimates, variances, and full chain</li></ul><p><strong>Notes</strong></p><ul><li>For ABC: Uses Population Monte Carlo ABC with adaptive epsilon selection</li><li>For ADVI: Uses Automatic Differentiation Variational Inference via Turing.jl</li><li>Parameter dictionary can be customized for each method (see get<em>param</em>dict_abc())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L316-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleWithMissingModel, Any}" href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleWithMissingModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.summary_stats(model::OneTimescaleWithMissingModel, data)</code></pre><p>Compute summary statistics (ACF or PSD) from time series data with missing values.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleWithMissingModel</code>: Model instance specifying summary statistic type</li><li><code>data</code>: Time series data to analyze (may contain NaN)</li></ul><p><strong>Returns</strong></p><p>For ACF (<code>summary_method = :acf</code>):</p><ul><li>Mean autocorrelation function up to <code>n_lags</code>, computed with missing data handling</li></ul><p>For PSD (<code>summary_method = :psd</code>):</p><ul><li>Mean Lomb-Scargle periodogram within specified frequency range</li></ul><p><strong>Notes</strong></p><ul><li>ACF uses comp<em>ac</em>time_missing for proper handling of NaN values</li><li>PSD uses Lomb-Scargle periodogram for irregular sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L235-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleWithMissing.one_timescale_with_missing_model-Tuple{Any, Any, Any}" href="#IntrinsicTimescales.OneTimescaleWithMissing.one_timescale_with_missing_model-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.OneTimescaleWithMissing.one_timescale_with_missing_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">one_timescale_with_missing_model(data, time, fit_method; kwargs...)</code></pre><p>Construct a OneTimescaleWithMissingModel for time series analysis with missing data.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: Input time series data (may contain NaN)</li><li><code>time</code>: Time points corresponding to the data</li><li><code>fit_method</code>: Fitting method to use (:abc or :advi)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>summary_method=:acf</code>: Summary statistic type (:psd or :acf)</li><li><code>data_sum_stats=nothing</code>: Pre-computed summary statistics</li><li><code>lags_freqs=nothing</code>: Custom lags or frequencies</li><li><code>prior=nothing</code>: Prior distribution(s) for parameters</li><li><code>n_lags=nothing</code>: Number of lags for ACF</li><li><code>distance_method=nothing</code>: Distance metric type</li><li><code>dt=time[2]-time[1]</code>: Time step</li><li><code>T=time[end]</code>: Total time span</li><li><code>numTrials=size(data,1)</code>: Number of trials</li><li><code>data_mean=nanmean(data)</code>: Data mean (excluding NaN)</li><li><code>data_sd=nanstd(data)</code>: Data standard deviation (excluding NaN)</li><li><code>freqlims=nothing</code>: Frequency limits for PSD</li><li><code>freq_idx=nothing</code>: Frequency selection mask</li><li><code>dims=ndims(data)</code>: Analysis dimension</li><li><code>distance_combined=false</code>: Use combined distance</li><li><code>weights=[0.5, 0.5]</code>: Distance weights</li><li><code>data_tau=nothing</code>: Pre-computed timescale</li></ul><p><strong>Returns</strong></p><ul><li><code>OneTimescaleWithMissingModel</code>: Model instance configured for specified analysis method</li></ul><p><strong>Notes</strong></p><p>Four main usage patterns:</p><ol><li>ACF-based ABC/ADVI: <code>summary_method=:acf</code>, <code>fit_method=:abc/:advi</code></li><li>PSD-based ABC/ADVI: <code>summary_method=:psd</code>, <code>fit_method=:abc/:advi</code></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_with_missing.jl#L85-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleAndOscWithMissing" href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleAndOscWithMissing</code></pre><p>Module for handling time series analysis with both oscillations and missing data. Uses specialized methods for handling NaN values:</p><ul><li>For ACF: Uses comp<em>ac</em>time_missing for proper handling of gaps</li><li>For PSD: Uses Lomb-Scargle periodogram for irregular sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleAndOscWithMissing.OneTimescaleAndOscWithMissingModel" href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing.OneTimescaleAndOscWithMissingModel"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing.OneTimescaleAndOscWithMissingModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OneTimescaleAndOscWithMissingModel &lt;: AbstractTimescaleModel</code></pre><p>Model for inferring a single timescale and oscillation from time series data with missing values. Parameters: [tau, freq, coeff] representing timescale, oscillation frequency, and oscillation coefficient.</p><p><strong>Fields</strong></p><ul><li><code>data::AbstractArray{&lt;:Real}</code>: Input time series data (may contain NaN)</li><li><code>time::AbstractVector{&lt;:Real}</code>: Time points corresponding to the data</li><li><code>fit_method::Symbol</code>: Fitting method (:abc, :advi)</li><li><code>summary_method::Symbol</code>: Summary statistic type (:psd or :acf)</li><li><code>lags_freqs</code>: Lags (for ACF) or frequencies (for PSD)</li><li><code>prior</code>: Prior distribution(s) for parameters</li><li><code>optalg</code>: Optimization algorithm for :optimization method</li><li><code>distance_method::Symbol</code>: Distance metric type (:linear or :logarithmic)</li><li><code>data_sum_stats</code>: Pre-computed summary statistics</li><li><code>dt::Real</code>: Time step between observations</li><li><code>T::Real</code>: Total time span</li><li><code>numTrials::Real</code>: Number of trials/iterations</li><li><code>data_mean::Real</code>: Mean of input data (excluding NaN)</li><li><code>data_sd::Real</code>: Standard deviation of input data (excluding NaN)</li><li><code>freqlims</code>: Frequency limits for PSD analysis</li><li><code>n_lags</code>: Number of lags for ACF</li><li><code>freq_idx</code>: Boolean mask for frequency selection</li><li><code>dims::Int</code>: Dimension along which to compute statistics</li><li><code>distance_combined::Bool</code>: Whether to use combined distance metric</li><li><code>weights::Vector{Real}</code>: Weights for combined distance</li><li><code>data_tau::Union{Real, Nothing}</code>: Pre-computed timescale</li><li><code>data_osc::Union{Real, Nothing}</code>: Pre-computed oscillation frequency</li><li><code>missing_mask::AbstractArray{Bool}</code>: Boolean mask indicating NaN positions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L51-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscWithMissingModel, Any}" href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscWithMissingModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.generate_data(model::OneTimescaleAndOscWithMissingModel, theta)</code></pre><p>Generate synthetic data from the Ornstein-Uhlenbeck process with oscillation and apply missing data mask.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscWithMissingModel</code>: Model instance containing simulation parameters</li><li><code>theta</code>: Vector containing parameters [tau, freq, coeff]</li></ul><p><strong>Returns</strong></p><ul><li>Synthetic time series data with oscillations and NaN values at positions specified by model.missing_mask</li></ul><p><strong>Notes</strong></p><ol><li>Generates complete OU process data with oscillation</li><li>Applies missing data mask from original data</li><li>Returns data with same missing value pattern as input</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L227-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.int_fit" href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">int_fit(model::OneTimescaleAndOscWithMissingModel, param_dict=nothing)</code></pre><p>Perform inference using the specified fitting method.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscWithMissingModel</code>: Model instance</li><li><code>param_dict=nothing</code>: Optional dictionary of algorithm parameters. If nothing, uses defaults.</li></ul><p><strong>Returns</strong></p><p>For ABC method:</p><ul><li><code>posterior_samples</code>: Matrix of accepted parameter samples</li><li><code>posterior_MAP</code>: Maximum a posteriori estimate</li><li><code>abc_record</code>: Full record of ABC iterations</li></ul><p>For ADVI method:</p><ul><li><code>ADVIResults</code>: Container with samples, MAP estimates, variances, and full chain</li></ul><p><strong>Notes</strong></p><ul><li>For ABC: Uses Population Monte Carlo ABC with adaptive epsilon selection</li><li>For ADVI: Uses Automatic Differentiation Variational Inference via Turing.jl</li><li>Parameter dictionary can be customized for each method (see get<em>param</em>dict_abc())</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L357-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscWithMissingModel, Any}" href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscWithMissingModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Models.summary_stats(model::OneTimescaleAndOscWithMissingModel, data)</code></pre><p>Compute summary statistics (ACF or PSD) from time series data with missing values.</p><p><strong>Arguments</strong></p><ul><li><code>model::OneTimescaleAndOscWithMissingModel</code>: Model instance specifying summary statistic type</li><li><code>data</code>: Time series data to analyze (may contain NaN)</li></ul><p><strong>Returns</strong></p><p>For ACF (<code>summary_method = :acf</code>):</p><ul><li>Mean autocorrelation function up to <code>n_lags</code>, computed with missing data handling</li></ul><p>For PSD (<code>summary_method = :psd</code>):</p><ul><li>Mean Lomb-Scargle periodogram within specified frequency range</li></ul><p><strong>Notes</strong></p><ul><li>ACF uses comp<em>ac</em>time_missing for proper handling of NaN values</li><li>PSD uses Lomb-Scargle periodogram for irregular sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L299-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.OneTimescaleAndOscWithMissing.combined_distance-Tuple{OneTimescaleAndOscWithMissingModel, Vararg{Any, 8}}" href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing.combined_distance-Tuple{OneTimescaleAndOscWithMissingModel, Vararg{Any, 8}}"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing.combined_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">combined_distance(model::OneTimescaleAndOscWithMissingModel, simulation_summary, data_summary,
                 weights, distance_method, data_tau, simulation_tau, data_osc, simulation_osc)</code></pre><p>Compute combined distance metric between simulated and observed data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: OneTimescaleAndOscWithMissingModel instance</li><li><code>simulation_summary</code>: Summary statistics from simulation</li><li><code>data_summary</code>: Summary statistics from observed data</li><li><code>weights</code>: Weights for combining distances</li><li><code>distance_method</code>: Distance metric type</li><li><code>data_tau</code>: Timescale from observed data</li><li><code>simulation_tau</code>: Timescale from simulation</li><li><code>data_osc</code>: Oscillation frequency from observed data</li><li><code>simulation_osc</code>: Oscillation frequency from simulation</li></ul><p><strong>Returns</strong></p><p>For ACF:</p><ul><li>Weighted combination of ACF distance and timescale distance</li></ul><p>For PSD:</p><ul><li>Weighted combination of PSD distance, timescale distance, and oscillation frequency distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/models/one_timescale_and_osc_with_missing.jl#L251-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ABCResults, AbstractTimescaleModel}" href="#IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ABCResults, AbstractTimescaleModel}"><code>IntrinsicTimescales.Plotting.posterior_predictive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot(container::ABCResults, model::Models.AbstractTimescaleModel; show::Bool=true)</code></pre><p>Plot posterior predictive check for ABC results. Shows the data summary statistics (ACF or PSD) with posterior predictive samples overlaid.</p><p><strong>Arguments</strong></p><ul><li><code>container::ABCResults</code>: Container with ABC results</li><li><code>model::Models.AbstractTimescaleModel</code>: Model used for inference</li><li><code>show::Bool=true</code>: Whether to display the plot</li><li><code>n_samples::Int=100</code>: Number of posterior samples to use for prediction</li></ul><p><strong>Returns</strong></p><ul><li>Plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/plotting.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ADVIResults, AbstractTimescaleModel}" href="#IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ADVIResults, AbstractTimescaleModel}"><code>IntrinsicTimescales.Plotting.posterior_predictive</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">posterior_predictive(container::ADVIResults, model::Models.AbstractTimescaleModel; show::Bool=true)</code></pre><p>Plot posterior predictive check for ADVI results. Shows the data summary statistics (ACF or PSD) with posterior predictive samples overlaid.</p><p><strong>Arguments</strong></p><ul><li><code>container::ADVIResults</code>: Container with ADVI results</li><li><code>model::Models.AbstractTimescaleModel</code>: Model used for inference</li><li><code>show::Bool=true</code>: Whether to display the plot</li><li><code>n_samples::Int=100</code>: Number of posterior samples to use for prediction</li></ul><p><strong>Returns</strong></p><ul><li>Plot object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/1a7a76206778e9899512d335055ae83971be95f9/src/core/plotting.jl#L150-L165">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#IntrinsicTimescales.ACW"><code>IntrinsicTimescales.ACW</code></a></li><li><a href="#IntrinsicTimescales.Distances"><code>IntrinsicTimescales.Distances</code></a></li><li><a href="#IntrinsicTimescales.IntrinsicTimescales"><code>IntrinsicTimescales.IntrinsicTimescales</code></a></li><li><a href="#IntrinsicTimescales.OneTimescale"><code>IntrinsicTimescales.OneTimescale</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleWithMissing"><code>IntrinsicTimescales.OneTimescaleWithMissing</code></a></li><li><a href="#IntrinsicTimescales.OrnsteinUhlenbeck"><code>IntrinsicTimescales.OrnsteinUhlenbeck</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats"><code>IntrinsicTimescales.SummaryStats</code></a></li><li><a href="#IntrinsicTimescales.Utils"><code>IntrinsicTimescales.Utils</code></a></li><li><a href="#IntrinsicTimescales.ABC.ABCResults"><code>IntrinsicTimescales.ABC.ABCResults</code></a></li><li><a href="#IntrinsicTimescales.ACW.ACWResults"><code>IntrinsicTimescales.ACW.ACWResults</code></a></li><li><a href="#IntrinsicTimescales.Models.AbstractTimescaleModel"><code>IntrinsicTimescales.Models.AbstractTimescaleModel</code></a></li><li><a href="#IntrinsicTimescales.Models.BaseModel"><code>IntrinsicTimescales.Models.BaseModel</code></a></li><li><a href="#IntrinsicTimescales.OneTimescale.OneTimescaleModel"><code>IntrinsicTimescales.OneTimescale.OneTimescaleModel</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleAndOsc.OneTimescaleAndOscModel"><code>IntrinsicTimescales.OneTimescaleAndOsc.OneTimescaleAndOscModel</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing.OneTimescaleAndOscWithMissingModel"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing.OneTimescaleAndOscWithMissingModel</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleWithMissing.OneTimescaleWithMissingModel"><code>IntrinsicTimescales.OneTimescaleWithMissing.OneTimescaleWithMissingModel</code></a></li><li><a href="#IntrinsicTimescales.TuringBackend.ADVIResults"><code>IntrinsicTimescales.TuringBackend.ADVIResults</code></a></li><li><a href="#IntrinsicTimescales.ABC.abc_results-Tuple{Vector{NamedTuple}}"><code>IntrinsicTimescales.ABC.abc_results</code></a></li><li><a href="#IntrinsicTimescales.ABC.basic_abc-Tuple{AbstractTimescaleModel}"><code>IntrinsicTimescales.ABC.basic_abc</code></a></li><li><a href="#IntrinsicTimescales.ABC.calc_weights-Tuple{VecOrMat{Float64}, VecOrMat{Float64}, Matrix{Float64}, Vector{Float64}, Union{Distributions.Distribution, Vector}}"><code>IntrinsicTimescales.ABC.calc_weights</code></a></li><li><a href="#IntrinsicTimescales.ABC.compute_adaptive_alpha-Tuple{Integer, Float64, Float64}"><code>IntrinsicTimescales.ABC.compute_adaptive_alpha</code></a></li><li><a href="#IntrinsicTimescales.ABC.draw_theta_pmc-NTuple{4, Any}"><code>IntrinsicTimescales.ABC.draw_theta_pmc</code></a></li><li><a href="#IntrinsicTimescales.ABC.effective_sample_size-Tuple{Vector{Float64}}"><code>IntrinsicTimescales.ABC.effective_sample_size</code></a></li><li><a href="#IntrinsicTimescales.ABC.find_MAP"><code>IntrinsicTimescales.ABC.find_MAP</code></a></li><li><a href="#IntrinsicTimescales.ABC.get_param_dict_abc-Tuple{}"><code>IntrinsicTimescales.ABC.get_param_dict_abc</code></a></li><li><a href="#IntrinsicTimescales.ABC.pmc_abc-Tuple{AbstractTimescaleModel}"><code>IntrinsicTimescales.ABC.pmc_abc</code></a></li><li><a href="#IntrinsicTimescales.ABC.select_epsilon-Tuple{Vector{Float64}, Float64}"><code>IntrinsicTimescales.ABC.select_epsilon</code></a></li><li><a href="#IntrinsicTimescales.ABC.weighted_covar-Tuple{Matrix{Float64}, Vector{Float64}}"><code>IntrinsicTimescales.ABC.weighted_covar</code></a></li><li><a href="#IntrinsicTimescales.ACW.acw-Tuple{Any, Any}"><code>IntrinsicTimescales.ACW.acw</code></a></li><li><a href="#IntrinsicTimescales.Distances.linear_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}"><code>IntrinsicTimescales.Distances.linear_distance</code></a></li><li><a href="#IntrinsicTimescales.Distances.logarithmic_distance-Tuple{Union{Real, AbstractArray}, Union{Real, AbstractArray}}"><code>IntrinsicTimescales.Distances.logarithmic_distance</code></a></li><li><a href="#IntrinsicTimescales.Models.check_acwtypes-Tuple{Any, Any}"><code>IntrinsicTimescales.Models.check_acwtypes</code></a></li><li><a href="#IntrinsicTimescales.Models.check_inputs-Tuple{Any, Any}"><code>IntrinsicTimescales.Models.check_inputs</code></a></li><li><a href="#IntrinsicTimescales.Models.check_model_inputs"><code>IntrinsicTimescales.Models.check_model_inputs</code></a></li><li><a href="#IntrinsicTimescales.Models.distance_function"><code>IntrinsicTimescales.Models.distance_function</code></a></li><li><a href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleWithMissingModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a></li><li><a href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a></li><li><a href="#IntrinsicTimescales.Models.distance_function-Tuple{OneTimescaleAndOscModel, Any, Any}"><code>IntrinsicTimescales.Models.distance_function</code></a></li><li><a href="#IntrinsicTimescales.Models.draw_theta"><code>IntrinsicTimescales.Models.draw_theta</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscWithMissingModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleAndOscModel, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Models.generate_data</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data"><code>IntrinsicTimescales.Models.generate_data</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data-Tuple{OneTimescaleWithMissingModel, Any}"><code>IntrinsicTimescales.Models.generate_data</code></a></li><li><a href="#IntrinsicTimescales.Models.generate_data_and_reduce-Tuple{AbstractTimescaleModel, Any}"><code>IntrinsicTimescales.Models.generate_data_and_reduce</code></a></li><li><a href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a></li><li><a href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a></li><li><a href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a></li><li><a href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a></li><li><a href="#IntrinsicTimescales.Models.int_fit"><code>IntrinsicTimescales.Models.int_fit</code></a></li><li><a href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a></li><li><a href="#IntrinsicTimescales.Models.summary_stats"><code>IntrinsicTimescales.Models.summary_stats</code></a></li><li><a href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a></li><li><a href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleWithMissingModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a></li><li><a href="#IntrinsicTimescales.Models.summary_stats-Tuple{OneTimescaleAndOscWithMissingModel, Any}"><code>IntrinsicTimescales.Models.summary_stats</code></a></li><li><a href="#IntrinsicTimescales.OneTimescale.combined_distance-Tuple{OneTimescaleModel, Vararg{Any, 5}}"><code>IntrinsicTimescales.OneTimescale.combined_distance</code></a></li><li><a href="#IntrinsicTimescales.OneTimescale.one_timescale_model-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.OneTimescale.one_timescale_model</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleAndOsc.combined_distance-Tuple{OneTimescaleAndOscModel, Vararg{Any, 8}}"><code>IntrinsicTimescales.OneTimescaleAndOsc.combined_distance</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleAndOscWithMissing.combined_distance-Tuple{OneTimescaleAndOscWithMissingModel, Vararg{Any, 8}}"><code>IntrinsicTimescales.OneTimescaleAndOscWithMissing.combined_distance</code></a></li><li><a href="#IntrinsicTimescales.OneTimescaleWithMissing.one_timescale_with_missing_model-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.OneTimescaleWithMissing.one_timescale_with_missing_model</code></a></li><li><a href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process-Tuple{Union{Real, Vector{&lt;:Real}}, Vararg{Real, 4}}"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process</code></a></li><li><a href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process_sciml-Union{Tuple{T}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer}, Tuple{Union{Vector{T}, T}, Real, Real, Real, Integer, Bool}} where T&lt;:Real"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_process_sciml</code></a></li><li><a href="#IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_with_oscillation-Union{Tuple{T}, Tuple{Vector{T}, Real, Real, Integer, Real, Real}} where T&lt;:Real"><code>IntrinsicTimescales.OrnsteinUhlenbeck.generate_ou_with_oscillation</code></a></li><li><a href="#IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ADVIResults, AbstractTimescaleModel}"><code>IntrinsicTimescales.Plotting.posterior_predictive</code></a></li><li><a href="#IntrinsicTimescales.Plotting.posterior_predictive-Tuple{ABCResults, AbstractTimescaleModel}"><code>IntrinsicTimescales.Plotting.posterior_predictive</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats._comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>IntrinsicTimescales.SummaryStats._comp_psd_lombscargle</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.acf_statsmodels-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.acf_statsmodels</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.acovf-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.acovf</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.bat_autocorr-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.bat_autocorr</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.bat_autocorr-Tuple{AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.SummaryStats.bat_autocorr</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len"><code>IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_len</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_weight"><code>IntrinsicTimescales.SummaryStats.bat_integrated_autocorr_weight</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_fft</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_fft</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_ac_time-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_time</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_ac_time_missing-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_ac_time_missing</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_cc-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Integer}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_cc</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_psd-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}} where T&lt;:Real"><code>IntrinsicTimescales.SummaryStats.comp_psd</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>IntrinsicTimescales.SummaryStats.comp_psd_adfriendly</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}"><code>IntrinsicTimescales.SummaryStats.comp_psd_lombscargle</code></a></li><li><a href="#IntrinsicTimescales.SummaryStats.prepare_lombscargle-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{S}, AbstractMatrix{Bool}, Real}} where {T&lt;:Number, S&lt;:Number}"><code>IntrinsicTimescales.SummaryStats.prepare_lombscargle</code></a></li><li><a href="#IntrinsicTimescales.TuringBackend.create_turing_model-Tuple{Any, Any}"><code>IntrinsicTimescales.TuringBackend.create_turing_model</code></a></li><li><a href="#IntrinsicTimescales.TuringBackend.fit_vi-Tuple{Any}"><code>IntrinsicTimescales.TuringBackend.fit_vi</code></a></li><li><a href="#IntrinsicTimescales.TuringBackend.get_param_dict_advi-Tuple{}"><code>IntrinsicTimescales.TuringBackend.get_param_dict_advi</code></a></li><li><a href="#IntrinsicTimescales.Utils.acw0-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}"><code>IntrinsicTimescales.Utils.acw0</code></a></li><li><a href="#IntrinsicTimescales.Utils.acw50-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.acw50</code></a></li><li><a href="#IntrinsicTimescales.Utils.acw_romberg-Union{Tuple{S}, Tuple{Real, AbstractVector{S}}} where S&lt;:Real"><code>IntrinsicTimescales.Utils.acw_romberg</code></a></li><li><a href="#IntrinsicTimescales.Utils.acweuler-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T&lt;:Real, S&lt;:Real}"><code>IntrinsicTimescales.Utils.acweuler</code></a></li><li><a href="#IntrinsicTimescales.Utils.expdecay-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.expdecay</code></a></li><li><a href="#IntrinsicTimescales.Utils.find_knee_frequency-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.find_knee_frequency</code></a></li><li><a href="#IntrinsicTimescales.Utils.find_oscillation_peak-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Utils.find_oscillation_peak</code></a></li><li><a href="#IntrinsicTimescales.Utils.fit_expdecay-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.fit_expdecay</code></a></li><li><a href="#IntrinsicTimescales.Utils.fit_gaussian-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, Real}"><code>IntrinsicTimescales.Utils.fit_gaussian</code></a></li><li><a href="#IntrinsicTimescales.Utils.fooof_fit-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T&lt;:Real"><code>IntrinsicTimescales.Utils.fooof_fit</code></a></li><li><a href="#IntrinsicTimescales.Utils.gaussian-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.gaussian</code></a></li><li><a href="#IntrinsicTimescales.Utils.lorentzian-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.lorentzian</code></a></li><li><a href="#IntrinsicTimescales.Utils.lorentzian_initial_guess-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>IntrinsicTimescales.Utils.lorentzian_initial_guess</code></a></li><li><a href="#IntrinsicTimescales.Utils.lorentzian_with_exponent-Tuple{Any, Any}"><code>IntrinsicTimescales.Utils.lorentzian_with_exponent</code></a></li><li><a href="#IntrinsicTimescales.Utils.residual_expdecay!-Tuple{Any, Any, Any}"><code>IntrinsicTimescales.Utils.residual_expdecay!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="fit_result/">« Results</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 15 May 2025 07:52">Thursday 15 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
