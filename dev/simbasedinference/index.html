<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · IntrinsicTimescales.jl</title><meta name="title" content="Overview · IntrinsicTimescales.jl"/><meta property="og:title" content="Overview · IntrinsicTimescales.jl"/><meta property="twitter:title" content="Overview · IntrinsicTimescales.jl"/><meta name="description" content="Documentation for IntrinsicTimescales.jl."/><meta property="og:description" content="Documentation for IntrinsicTimescales.jl."/><meta property="twitter:description" content="Documentation for IntrinsicTimescales.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../home/">IntrinsicTimescales.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../home/">Getting Started</a></li><li><span class="tocitem">Explanation</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Practice</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../practice/practice_intro/">Practice</a></li><li><a class="tocitem" href="../practice/practice_1_acf/">Building the Autocorrelation Function</a></li><li><a class="tocitem" href="../practice/practice_2_acw/">Autocorrelation Windows</a></li><li><a class="tocitem" href="../practice/practice_3_ou/">Ornstein-Uhlenbeck Process as a Generative Model for ACF</a></li><li><a class="tocitem" href="../practice/practice_4_psd/">Dealing with Oscillatory Artifacts using Fourier Transformation</a></li><li><a class="tocitem" href="../practice/practice_5_bayesian/">Bayesian Estimation of Intrinsic Timescales</a></li></ul></li><li><a class="tocitem" href="../theory/theory/">Theory</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial/tutorial_1_acw/">Navigating the Forest of INT Metrics</a></li><li><a class="tocitem" href="../tutorial/tutorial_2_mne/">Usage with MNE-Python</a></li><li><a class="tocitem" href="../tutorial/tutorial_3_ft/">Usage with FieldTrip</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Implementation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../acw/">Model-Free Timescale Estimation</a></li><li><input class="collapse-toggle" id="menuitem-4-1-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1-2"><span class="docs-label">Simulation Based Timescale Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Overview</a><ul class="internal"><li><a class="tocitem" href="#Model-Types"><span>Model Types</span></a></li><li><a class="tocitem" href="#Fitting-Methods-ABC"><span>Fitting Methods - ABC</span></a></li><li><a class="tocitem" href="#Fitting-Methods-ADVI"><span>Fitting Methods - ADVI</span></a></li><li><a class="tocitem" href="#Notes-on-Summary-Statistics"><span>Notes on Summary Statistics</span></a></li></ul></li><li><a class="tocitem" href="../one_timescale/">One Timescale Model</a></li><li><a class="tocitem" href="../one_timescale_with_missing/">One Timescale Model with Missing Data</a></li><li><a class="tocitem" href="../one_timescale_and_osc/">One Timescale Model with Oscillations</a></li><li><a class="tocitem" href="../one_timescale_and_osc_with_missing/">One Timescale Model with Oscillations and Missing Data</a></li><li><a class="tocitem" href="../fit_parameters/">Model Fitting and Parameters</a></li><li><a class="tocitem" href="../fit_result/">Results</a></li></ul></li></ul></li><li><a class="tocitem" href="../">API</a></li></ul></li><li><a class="tocitem" href="../citations/">Citations</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../developer/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li><a class="is-disabled">Implementation</a></li><li><a class="is-disabled">Simulation Based Timescale Estimation</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/master/docs/src/simbasedinference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sim"><a class="docs-heading-anchor" href="#sim">Simulation Based Timescale Estimation</a><a id="sim-1"></a><a class="docs-heading-anchor-permalink" href="#sim" title="Permalink"></a></h1><p>In simulation based methods, your data is assumed to come from a generative model and IntrinsicTimescales.jl performs Bayesian parameter estimation (via approximate Bayesian computation, ABC or automatic differentiation variational inference, ADVI) on that model. The goal is to match the autocorrelation function (ACF) or equivalently, power spectral density (PSD) of the generative model and data. The simplest generative model is an Ornstein-Uhlenbeck (OU) process with only one parameter to estimate. In case of oscillations, an oscillation is linearly added to the output of the Ornstein-Uhlenbeck process. If some of your data is missing, indicated by <code>NaN</code> or <code>missing</code>, the data points from the generative model are replaced by <code>NaN</code>s. We note that the variance of noise in the OU process is not fit to data as we scale the output of simulations to match the variance of data in order to reduce the burden or parameter fitting procedure. </p><p>All methods assume that your data has one dimension for trials and one dimension for time points. From each trial, IntrinsicTimescales.jl calculates one summary statistic (ACF or PSD) and averages them across trials to get a less noisy estimate. The simulations from the generative model have the same data structure (same number of data points, trials and time resolution) as your data. The goal of the simulation based methods is minimizing the distance between the ACF or PSD of your model and data. Then the parameter corresponding to INT in your model is hopefully the real INT. </p><h2 id="Model-Types"><a class="docs-heading-anchor" href="#Model-Types">Model Types</a><a id="Model-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Types" title="Permalink"></a></h2><p>There are four main functions in IntrinsicTimescales.jl to perform simulation based timescale estimation: <a href="../one_timescale/"><code>one_timescale_model</code></a>, <a href="../one_timescale_and_osc/"><code>one_timescale_and_osc_model</code></a>, <a href="../one_timescale_with_missing/"><code>one_timescale_with_missing_model</code></a>, <a href="../one_timescale_and_osc_with_missing/"><code>one_timescale_and_osc_with_missing_model</code></a>. For each model, one can choose between <code>:abc</code> or <code>:advi</code> as the inference method and <code>:acf</code> or <code>:psd</code> as the summary method. All models have the same syntax with differences in implementation. The detailed usage is documented in <a href="../one_timescale/"><code>one_timescale_model</code></a> - other model pages focus on specific differences. </p><p>The following table summarizes the four models. </p><table><tr><th style="text-align: right">Model</th><th style="text-align: right">Generative Model</th><th style="text-align: right">Summary Method (<code>:acf</code> or <code>:psd</code>)</th><th style="text-align: right">Supported Inference Methods (<code>:abc</code> or <code>:advi</code>)</th></tr><tr><td style="text-align: right"><code>one_timescale_model</code></td><td style="text-align: right">Ornstein-Uhlenbeck process</td><td style="text-align: right"><a href="../#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_fft</code></a> or <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>comp_psd_adfriendly</code></a></td><td style="text-align: right">ABC and ADVI</td></tr><tr><td style="text-align: right"><code>one_timescale_and_osc_model</code></td><td style="text-align: right">Sinusoid added on Ornstein-Uhlenbeck process</td><td style="text-align: right"><a href="../#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_fft</code></a> or <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>comp_psd_adfriendly</code></a></td><td style="text-align: right">ABC and ADVI</td></tr><tr><td style="text-align: right"><code>one_timescale_with_missing_model</code></td><td style="text-align: right">Ornstein-Uhlenbeck process with missing data replaced by NaNs</td><td style="text-align: right"><a href="../#IntrinsicTimescales.SummaryStats.comp_ac_time_missing-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_time_missing</code></a> or <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}"><code>comp_psd_lombscargle</code></a></td><td style="text-align: right">ABC (for both ACF and PSD), ADVI (only ACF)</td></tr><tr><td style="text-align: right"><code>one_timescale_and_osc_with_missing_model</code></td><td style="text-align: right">Sinusoid added on Ornstein-Uhlenbeck process with missing data replaced by NaNs</td><td style="text-align: right"><a href="../#IntrinsicTimescales.SummaryStats.comp_ac_time_missing-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_time_missing</code></a> or <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}"><code>comp_psd_lombscargle</code></a></td><td style="text-align: right">ABC (for both ACF and PSD), ADVI (only ACF)</td></tr></table><p>All models are fit with <code>int_fit</code> function and return <a href="../fit_result/#ADVIResults"><code>ADVIResults</code></a> or <a href="../fit_result/#ABCResults"><code>ABCResults</code></a> type. See the <a href="../fit_result/">Fitting and Results</a> section for details. </p><h2 id="Fitting-Methods-ABC"><a class="docs-heading-anchor" href="#Fitting-Methods-ABC">Fitting Methods - ABC</a><a id="Fitting-Methods-ABC-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-Methods-ABC" title="Permalink"></a></h2><p>Approximate Bayesian Computation (ABC) is a method to approximate the posterior without solving the likelihood function. The algorithm has two steps: ABC (<a href="../#IntrinsicTimescales.ABC.basic_abc-Tuple{AbstractTimescaleModel}"><code>basic_abc</code></a>) and population monte carlo (PMC, <a href="../#IntrinsicTimescales.ABC.pmc_abc-Tuple{AbstractTimescaleModel}"><code>pmc_abc</code></a>). In pseudocode, ABC is as follows:</p><pre><code class="nohighlight hljs">summary = summary_statistic(empirical_data)
accepted_samples = []
WHILE length(accepted_samples) &lt; min_accepted
    theta = sample_from_prior()
    model_data = simulate_data(model, theta)
    distance = compute_distance(summary, model_data)
    IF distance &lt; epsilon
        push!(accepted_samples, theta)
    END IF
END WHILE</code></pre><p>PMC uses ABC samples as the initial population and iteratively updates. For more details, refer to <a href="https://www.nature.com/articles/s43588-022-00214-3">Zeraati et al, 2021</a>. </p><p>To change the parameters of the ABC algorithm, first use the function <a href="../#IntrinsicTimescales.ABC.get_param_dict_abc-Tuple{}"><code>get_param_dict_abc</code></a> to get the default parameters. Then modify the parameters and pass them to the function <code>int_fit</code>. For example, </p><pre><code class="language-julia hljs">using IntrinsicTimescales
timescale = 0.3 # true timescales
variance = 1.0 # variance of data
duration = 10.0 # duration of data
n_trials = 10 # How many trials
fs = 500.0 # Sampling rate
data = generate_ou_process(timescale, variance, 1/fs, duration, n_trials)
time = (1/fs):(1/fs):duration
model = one_timescale_model(data, time, :abc)
param_dict = get_param_dict_abc()
param_dict[:convergence_window] = 10
result = int_fit(model, param_dict)
int_map = result.MAP[1] # Maximum a posteriori </code></pre><p>The parameters are detailed in <a href="../fit_parameters/">Parameters for Approximate Bayesian Computation</a> section.</p><h2 id="Fitting-Methods-ADVI"><a class="docs-heading-anchor" href="#Fitting-Methods-ADVI">Fitting Methods - ADVI</a><a id="Fitting-Methods-ADVI-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-Methods-ADVI" title="Permalink"></a></h2><p>Note: ADVI functionality is experimental. Proceed with caution. </p><p>Automatic Differentiation Variational Inference (ADVI) approximates the posterior using variational methods. Instead of using MCMC directly, ADVI uses gradient descent to find the optimal parameters that minimize the Kullback-Leibler divergence between the variational posterior and the true posterior. IntrinsicTimescales.jl uses the <a href="https://turing.ml/stable/"><code>Turing.jl</code></a> package to perform ADVI. For more details, refer to <a href="https://turing.ml/v0.22/docs/for-developers/variational_inference">Turing documentation</a> or <a href="https://arxiv.org/abs/1603.00788">Kucukelbir et al, 2017</a>. </p><p>IntrinsicTimescales.jl states the probabilistic problem as the likelihood of each data point in the summary statistic of the data coming from a Gaussian distribution with mean generative model&#39;s summary statistic and some uncertainty around it. More clearly:</p><p class="math-container">\[\textrm{data summary statistic}_i \sim N(\textrm{model summary statistic}_i, \sigma)\]</p><p>Similar to ABC, in order to change the parameters of the ADVI algorithm, use the function <a href="../#IntrinsicTimescales.TuringBackend.get_param_dict_advi-Tuple{}"><code>get_param_dict_advi</code></a> to get the default parameters, modify them, and pass them to the function <code>fit</code>. Example:</p><pre><code class="language-julia hljs">model = one_timescale_and_osc_model(data, time, :advi)
param_dict = get_param_dict_advi()
param_dict[:n_iterations] = 20
results = int_fit(model, param_dict)</code></pre><p>See <a href="../fit_parameters/">Parameters for Automatic Differentiation Variational Inference</a> section for details on parameters.</p><h2 id="Notes-on-Summary-Statistics"><a class="docs-heading-anchor" href="#Notes-on-Summary-Statistics">Notes on Summary Statistics</a><a id="Notes-on-Summary-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-Summary-Statistics" title="Permalink"></a></h2><p>Each model uses either ACF or PSD as the summary statistic. As can be seen from the table above, with no missing data, <a href="../#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_fft</code></a> and <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>comp_psd_adfriendly</code></a> are used. <a href="../#IntrinsicTimescales.SummaryStats.comp_ac_fft-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:Real"><code>comp_ac_fft</code></a> calculates the ACF using the fast fourier transform (FFT). <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_adfriendly-Tuple{AbstractArray{&lt;:Real}, Real}"><code>comp_psd_adfriendly</code></a> is an autodifferentiable implementation of <a href="../#IntrinsicTimescales.SummaryStats.comp_psd-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}} where T&lt;:Real"><code>comp_psd</code></a>; both use Periodogram method with a Hamming window. In case of missing data, ACF is calculated in the time domain with the same techniques used in <a href="https://www.statsmodels.org/stable/generated/statsmodels.tsa.stattools.acf.html">statsmodels.tsa.stattools.acf</a> with <code>missing=conservative</code> option. For PSD, Lomb-Scargle method (via <a href="https://juliaastro.org/LombScargle.jl/stable/">LombScargle.jl</a>) with the function  <a href="../#IntrinsicTimescales.SummaryStats.comp_psd_lombscargle-Tuple{AbstractVector{&lt;:Number}, AbstractVector{&lt;:Number}, AbstractVector{Bool}, Real}"><code>comp_psd_lombscargle</code></a> is used but currently it is not autodifferentiable. If you wish to use PSD with simulation-based inference in the case of missing data, you would need to use ABC. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../acw/">« Model-Free Timescale Estimation</a><a class="docs-footer-nextpage" href="../one_timescale/">One Timescale Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 14 September 2025 08:16">Sunday 14 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
