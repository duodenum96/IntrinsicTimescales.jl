<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Fitting and Parameters · IntrinsicTimescales.jl</title><meta name="title" content="Model Fitting and Parameters · IntrinsicTimescales.jl"/><meta property="og:title" content="Model Fitting and Parameters · IntrinsicTimescales.jl"/><meta property="twitter:title" content="Model Fitting and Parameters · IntrinsicTimescales.jl"/><meta name="description" content="Documentation for IntrinsicTimescales.jl."/><meta property="og:description" content="Documentation for IntrinsicTimescales.jl."/><meta property="twitter:description" content="Documentation for IntrinsicTimescales.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../home/">IntrinsicTimescales.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../home/">Getting Started</a></li><li><span class="tocitem">Practice</span><ul><li><a class="tocitem" href="../practice/practice_intro/">Practice</a></li><li><a class="tocitem" href="../practice/practice_1_acf/">Building the Autocorrelation Function</a></li><li><a class="tocitem" href="../practice/practice_2_acw/">Autocorrelation Windows</a></li><li><a class="tocitem" href="../practice/practice_3_ou/">Ornstein-Uhlenbeck Process as a Generative Model for ACF</a></li><li><a class="tocitem" href="../practice/practice_4_psd/">Dealing with Oscillatory Artifacts using Fourier Transformation</a></li><li><a class="tocitem" href="../practice/practice_5_bayesian/">Bayesian Estimation of Intrinsic Timescales</a></li></ul></li><li><a class="tocitem" href="../theory/theory/">Theory</a></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../acw/">Model-Free Timescale Estimation</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Simulation Based Timescale Estimation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simbasedinference/">Overview</a></li><li><a class="tocitem" href="../one_timescale/">One Timescale Model</a></li><li><a class="tocitem" href="../one_timescale_with_missing/">One Timescale Model with Missing Data</a></li><li><a class="tocitem" href="../one_timescale_and_osc/">One Timescale Model with Oscillations</a></li><li><a class="tocitem" href="../one_timescale_and_osc_with_missing/">One Timescale Model with Oscillations and Missing Data</a></li><li class="is-active"><a class="tocitem" href>Model Fitting and Parameters</a><ul class="internal"><li><a class="tocitem" href="#Parameters-for-Approximate-Bayesian-Computation-(ABC)"><span>Parameters for Approximate Bayesian Computation (ABC)</span></a></li><li><a class="tocitem" href="#Parameters-for-Automatic-Differentiation-Variational-Inference-(ADVI)"><span>Parameters for Automatic Differentiation Variational Inference (ADVI)</span></a></li></ul></li><li><a class="tocitem" href="../fit_result/">Results</a></li></ul></li></ul></li><li><a class="tocitem" href="../">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation</a></li><li><a class="is-disabled">Simulation Based Timescale Estimation</a></li><li class="is-active"><a href>Model Fitting and Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Fitting and Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/duodenum96/IntrinsicTimescales.jl/blob/master/docs/src/fit_parameters.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-Fitting-and-Parameters"><a class="docs-heading-anchor" href="#Model-Fitting-and-Parameters">Model Fitting and Parameters</a><a id="Model-Fitting-and-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Fitting-and-Parameters" title="Permalink"></a></h1><p>All models are fit with <code>fit</code> function and return <a href="../fit_result/#ADVIResults"><code>ADVIResults</code></a> or <a href="../fit_result/#ABCResults"><code>ABCResults</code></a> type. The <code>fit</code> function has the following signature:</p><pre><code class="language-julia hljs">results = fit(model, param_dict=nothing)</code></pre><p>The function determines the inference method based on model attributes which the user provides when initiating the model. When <code>param_dict</code> is not provided, the function uses the default parameters for the inference method, which can be seen with <a href="../#IntrinsicTimescales.TuringBackend.get_param_dict_advi-Tuple{}"><code>get_param_dict_advi</code></a> and <a href="../#IntrinsicTimescales.ABC.get_param_dict_abc-Tuple{}"><code>get_param_dict_abc</code></a> functions. </p><h2 id="Parameters-for-Approximate-Bayesian-Computation-(ABC)"><a class="docs-heading-anchor" href="#Parameters-for-Approximate-Bayesian-Computation-(ABC)">Parameters for Approximate Bayesian Computation (ABC)</a><a id="Parameters-for-Approximate-Bayesian-Computation-(ABC)-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters-for-Approximate-Bayesian-Computation-(ABC)" title="Permalink"></a></h2><p>The parameters of ABC can be accessed and modified through the <code>get_param_dict_abc()</code> function. </p><h4 id="General-ABC-Parameters"><a class="docs-heading-anchor" href="#General-ABC-Parameters">General ABC Parameters</a><a id="General-ABC-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#General-ABC-Parameters" title="Permalink"></a></h4><ul><li><code>epsilon_0::Float64 = 1.0</code>: Initial acceptance threshold. If the distance between the observed data and the simulated data is less than <code>epsilon_0</code>, the sample is accepted in the initial step of ABC. Subsequent steps change the epsilon value to adapt better. </li><li><code>max_iter::Int = 10000</code>: Maximum number of iterations per basic ABC step</li><li><code>min_accepted::Int = 100</code>: The number of accepted samples for basic ABC</li><li><code>steps::Int = 30</code>: Number of PMC steps to perform</li><li><code>sample_only::Bool = false</code>: If true, only perform sampling without adaptation between basic ABC runs</li></ul><h4 id="Epsilon-Selection-Parameters"><a class="docs-heading-anchor" href="#Epsilon-Selection-Parameters">Epsilon Selection Parameters</a><a id="Epsilon-Selection-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Epsilon-Selection-Parameters" title="Permalink"></a></h4><p>Different from the Zeraati et al. (2022) method, we adaptively change the epsilon value between basic ABC steps. The epsilon selection procedure adaptively adjusts the acceptance threshold based on the current acceptance rate and distance distribution. The procedure works as follows:</p><ol><li><p>First, invalid distances (NaN values and distances above <code>distance_max</code>) are filtered out.</p></li><li><p>Three quantiles are computed from the valid distances:</p><ul><li>Lower quantile (<code>quantile_lower</code>) for conservative threshold</li><li>Initial quantile (<code>quantile_init</code>) for first iteration</li><li>Upper quantile (<code>quantile_upper</code>) for relaxed threshold</li></ul></li><li><p>An adaptive alpha value is computed based on:</p><ul><li>Progress through iterations (iteration/total<em>iterations) to decay from alpha</em>max to alpha_min</li><li>Difference between current and target acceptance rates:<ul><li>If difference &gt; acc<em>rate</em>far: Alpha increases to min(alpha<em>max, base</em>alpha * alpha<em>far</em>mult)</li><li>If difference &lt; acc<em>rate</em>close: Alpha decreases to max(alpha<em>min, base</em>alpha * alpha<em>close</em>mult) </li><li>Otherwise: Uses base alpha from iteration progress</li></ul></li></ul></li><li><p>The new epsilon is then selected:</p><ul><li>For first iteration: Uses the initial quantile</li><li>For subsequent iterations:<ul><li>If acceptance rate is too high: Epsilon is set to the maximum of the lower quantile and epsilon * (1-alpha)</li><li>If acceptance rate is too low: Epsilon is set to the minimum of the upper quantile and epsilon * (1+alpha) </li><li>If acceptance rate is within buffer of target: Epsilon stays same</li></ul></li></ul></li></ol><p>This adaptive procedure helps balance exploration and exploitation during the ABC sampling process by sampling wider for initial steps and narrowing down as the algorithm converges. </p><p>Parameters controlling epsilon selection:</p><ul><li><code>target_acc_rate::Float64 = 0.01</code>: Targeted acceptance rate for epsilon adaptation</li><li><code>distance_max::Float64 = 10.0</code>: Maximum distance to consider valid</li><li><code>quantile_lower::Float64 = 25.0</code>: Lower quantile for epsilon adjustment</li><li><code>quantile_upper::Float64 = 75.0</code>: Upper quantile for epsilon adjustment</li><li><code>quantile_init::Float64 = 50.0</code>: Initial quantile when no acceptance rate</li><li><code>acc_rate_buffer::Float64 = 0.1</code>: Buffer around target acceptance rate</li></ul><h4 id="Adaptive-Alpha-Parameters"><a class="docs-heading-anchor" href="#Adaptive-Alpha-Parameters">Adaptive Alpha Parameters</a><a id="Adaptive-Alpha-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Alpha-Parameters" title="Permalink"></a></h4><ul><li><code>alpha_max::Float64 = 0.9</code>: Maximum adaptation rate</li><li><code>alpha_min::Float64 = 0.1</code>: Minimum adaptation rate</li><li><code>acc_rate_far::Float64 = 2.0</code>: Threshold for &quot;far from target&quot; adjustment</li><li><code>acc_rate_close::Float64 = 0.2</code>: Threshold for &quot;close to target&quot; adjustment</li><li><code>alpha_far_mult::Float64 = 1.5</code>: Multiplier for alpha when far from target</li><li><code>alpha_close_mult::Float64 = 0.5</code>: Multiplier for alpha when close to target</li></ul><h4 id="Early-Stopping-Parameters"><a class="docs-heading-anchor" href="#Early-Stopping-Parameters">Early Stopping Parameters</a><a id="Early-Stopping-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Early-Stopping-Parameters" title="Permalink"></a></h4><ul><li><code>convergence_window::Int = 3</code>: Number of iterations to check for convergence</li><li><code>theta_rtol::Float64 = 1e-2</code>: Relative tolerance for parameter convergence</li><li><code>theta_atol::Float64 = 1e-3</code>: Absolute tolerance for parameter convergence</li><li><code>target_epsilon::Float64 = 5e-3</code>: Stop the PMC if the distance between the observed data and the simulated data is less than <code>target_epsilon</code>.</li><li><code>minAccRate::Float64 = 0.01</code>: If acceptance rate of basic ABC steps is below <code>minAccRate</code>, the algorithm stops.</li></ul><h4 id="Numerical-Stability-Parameters"><a class="docs-heading-anchor" href="#Numerical-Stability-Parameters">Numerical Stability Parameters</a><a id="Numerical-Stability-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Stability-Parameters" title="Permalink"></a></h4><ul><li><code>jitter::Float64 = 1e-6</code>: Small value added to covariance diagonal for numerical stability</li></ul><h4 id="Display-Parameters"><a class="docs-heading-anchor" href="#Display-Parameters">Display Parameters</a><a id="Display-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Display-Parameters" title="Permalink"></a></h4><ul><li><code>show_progress::Bool = true</code>: Whether to show progress bar</li><li><code>verbose::Bool = true</code>: Whether to print detailed information</li></ul><h4 id="MAP-Estimation-Parameters"><a class="docs-heading-anchor" href="#MAP-Estimation-Parameters">MAP Estimation Parameters</a><a id="MAP-Estimation-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#MAP-Estimation-Parameters" title="Permalink"></a></h4><p>The <code>find_MAP</code> function estimates the maximum a posteriori (MAP) parameters by performing a grid search over the parameter space. It takes the accepted parameters from the final ABC step and creates a grid of N random positions within the parameter bounds. For each parameter dimension, it estimates the probability density using kernel density estimation (KDE) and evaluates the density at the grid positions. The MAP estimate is then determined by finding the position with maximum probability density for each parameter. This provides a point estimate of the most probable parameter values given the posterior samples.</p><ul><li><code>N::Int = 10000</code>: Number of samples for maximum a posteriori (MAP) estimation grid search</li></ul><p>To modify these parameters, create a dictionary with your desired values and pass it to the <code>fit</code> function:</p><pre><code class="language-julia hljs">model = one_timescale_model(data, time, :abc)
param_dict = get_param_dict_abc()
param_dict[:convergence_window] = 10
param_dict[:max_iter] = 20000
results = fit(model, param_dict)</code></pre><h2 id="Parameters-for-Automatic-Differentiation-Variational-Inference-(ADVI)"><a class="docs-heading-anchor" href="#Parameters-for-Automatic-Differentiation-Variational-Inference-(ADVI)">Parameters for Automatic Differentiation Variational Inference (ADVI)</a><a id="Parameters-for-Automatic-Differentiation-Variational-Inference-(ADVI)-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters-for-Automatic-Differentiation-Variational-Inference-(ADVI)" title="Permalink"></a></h2><p>ADVI is performed via <a href="https://turing.ml/v0.22/docs/for-developers/variational_inference"><code>Turing.jl</code></a> package. See the <a href="https://turing.ml/dev/tutorials/09-variational-inference/">variational inference tutorial</a> to learn more about Turing&#39;s ADVI implementation. The parameters can be accessed and modified through the <code>get_param_dict_advi()</code> function. </p><ul><li><code>n_samples::Int = 4000</code>: Number of posterior samples to draw after fitting</li><li><code>n_iterations::Int = 50</code>: Number of ADVI optimization iterations. Increase this number if your model is not fitting well.</li><li><code>n_elbo_samples::Int = 20</code>: Number of samples used to estimate the ELBO (Evidence Lower BOund) during optimization. Increase this number if your model is not fitting well.</li><li><code>autodiff = AutoForwardDiff()</code>: The automatic differentiation backend to use for computing gradients. Currently, only <code>AutoForwardDiff()</code> is supported.</li></ul><p>To modify these parameters, create a dictionary with your desired values and pass it to the <code>fit</code> function:</p><pre><code class="language-julia hljs">model = one_timescale_model(data, time, :advi)
param_dict = get_param_dict_advi()
param_dict[:n_samples] = 8000
param_dict[:n_elbo_samples] = 60
results = fit(model, param_dict)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../one_timescale_and_osc_with_missing/">« One Timescale Model with Oscillations and Missing Data</a><a class="docs-footer-nextpage" href="../fit_result/">Results »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 15 May 2025 07:52">Thursday 15 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
